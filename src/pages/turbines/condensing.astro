---
import type { Lang } from '@/i18n';
import { getBaseUrl } from '@/i18n';
import BaseLayout from '@/layouts/BaseLayout.astro';
import Breadcrumbs from '@/components/Breadcrumbs.astro';
import CtaFaq from '@/components/CtaFaq.astro';
import Faq from '@/components/Faq.astro';

const lang: Lang = 'ru';
const base = getBaseUrl(lang);

const faqItems = [
  {
    question: "Чем конденсационная турбина отличается от противодавленческой?",
    answer: "Конденсационная турбина полностью использует энергию пара, направляя отработанный пар в конденсатор под вакуумом. Противодавленческая турбина выпускает пар при повышенном давлении для использования в технологических процессах. Конденсационные турбины обеспечивают максимальную выработку электроэнергии."
  },
  {
    question: "Где применяются конденсационные турбины?",
    answer: "Конденсационные турбины применяются на электростанциях, где основная цель — максимальная выработка электроэнергии. Также используются на промышленных предприятиях в качестве внутренних электростанций (ИЭС) для обеспечения независимого электроснабжения."
  },
  {
    question: "Что такое экстракционная конденсация?",
    answer: "Экстракционная конденсационная турбина позволяет отбирать часть пара на промежуточной ступени для технологических нужд, при этом остальной пар направляется в конденсатор. Это обеспечивает гибкость в одновременном производстве электроэнергии и технологического пара."
  },
  {
    question: "Какие преимущества у турбин с двойным отбором?",
    answer: "Турбины с двойным регулируемым отбором позволяют получать пар двух различных давлений для разных технологических процессов. Это универсальное решение для предприятий с разнообразными потребностями в паре и электроэнергии."
  }
];

const turbineTypes = [
  {
    title: 'Прямая конденсация',
    subtitle: 'Straight Condensing',
    description: 'Тепловая энергия пара полностью преобразуется в механическую энергию (крутящий момент). Механическая энергия используется для выработки электроэнергии.',
    features: [
      'Максимальное использование энергии пара',
      'Применение на внутренних электростанциях (ИЭС)',
      'Использование продувки для деаэратора',
      'Оптимально для генерации электроэнергии'
    ],
    icon: 'straight',
    image: '/img/turbines/enhanced_turbine_5.webp'
  },
  {
    title: 'Экстракционная конденсация',
    subtitle: 'Extraction Condensing',
    description: 'Одна из самых универсальных установок с точки зрения эксплуатации. Обеспечивает пар постоянного давления за счёт контролируемого отбора при различных условиях загрузки турбины.',
    features: [
      'Регулируемый отбор пара',
      'Мембранные или проходные клапаны',
      'Замкнутый механизм обратной связи',
      'Максимальная эффективность цикла'
    ],
    icon: 'extraction',
    image: '/img/turbines/Экстракционная конденсация.webp'
  },
  {
    title: 'Двойной регулируемый отбор',
    subtitle: 'Double Extraction Condensing',
    description: 'Одноцилиндровая конструкция с регулирующими клапанами отбора на двух различных ступенях для обеспечения пара постоянного давления при заранее заданных значениях.',
    features: [
      'Два уровня давления отбора',
      'Автоматическая регулировка',
      'Гибкость эксплуатации',
      'Оптимизация под сезонные нагрузки'
    ],
    icon: 'double',
    image: '/img/turbines/Конденсация с отводом.webp'
  }
];

const advantages = [
  {
    title: 'Максимальная выработка',
    description: 'Полное использование энергии пара обеспечивает максимальную выработку электроэнергии на единицу расхода пара',
    icon: '/img/icons/bolt.svg',
    stat: 'до 95%',
    unit: 'использования'
  },
  {
    title: 'Гибкость эксплуатации',
    description: 'Возможность работы в широком диапазоне нагрузок с сохранением высокого КПД',
    icon: '/img/icons/effective.svg',
    stat: '30-100%',
    unit: 'нагрузки'
  },
  {
    title: 'Регулируемый отбор',
    description: 'Точный контроль давления и расхода отбираемого пара для технологических нужд',
    icon: '/img/icons/quality.svg',
    stat: '±0.5%',
    unit: 'точность'
  },
  {
    title: 'Высокий КПД',
    description: 'Конденсационный цикл обеспечивает максимальную термодинамическую эффективность',
    icon: '/img/icons/full_ready.svg',
    stat: 'до 42%',
    unit: 'КПД цикла'
  },
  {
    title: 'Длительный ресурс',
    description: 'Расчётный срок службы более 200 000 часов при правильной эксплуатации',
    icon: '/img/icons/fast.svg',
    stat: '200 000+',
    unit: 'часов'
  },
  {
    title: 'Автоматизация',
    description: 'Современные системы управления с замкнутым контуром обратной связи',
    icon: '/img/icons/design.svg',
    stat: '100%',
    unit: 'автоматика'
  },
  {
    title: 'Широкий диапазон',
    description: 'Мощность от 4 до 120 МВт для различных промышленных и энергетических применений',
    icon: '/img/icons/price.svg',
    stat: '4-120',
    unit: 'МВт'
  },
  {
    title: 'Комплексные решения',
    description: 'Поставка с конденсатором, системой маслоснабжения и автоматикой',
    icon: '/img/icons/easy_install.svg',
    stat: 'под ключ',
    unit: 'поставка'
  }
];
---

<BaseLayout 
  lang={lang} 
  title="Конденсационные паровые турбины 4-120 МВт — РУСТРЕЙД"
  description="Конденсационные паровые турбины с регулируемым отбором мощностью 4-120 МВт. Прямая конденсация, экстракционная, двойной отбор. КПД до 42%. Ресурс 200 000+ часов."
  keywords="конденсационные турбины купить, паровые турбины для электростанций, экстракционная конденсация, турбины 4-120 МВт, РУСТРЕЙД"
  image="/img/turbines/enhanced_turbine_5.webp"
  faqData={faqItems}
  breadcrumbs={[{ name: 'Паровые турбины', url: '/turbines' }, { name: 'Конденсационные турбины', url: '/turbines/condensing' }]}
  productData={{
    name: 'Конденсационные паровые турбины',
    description: 'Конденсационные паровые турбины с регулируемым отбором мощностью 4-120 МВт',
    image: '/img/turbines/enhanced_turbine_5.webp',
    category: 'Паровые турбины',
    sku: 'CONDENSING-TURBINE'
  }}
>
  <Breadcrumbs items={[
    { label: 'Паровые турбины', href: '/turbines' },
    { label: 'Конденсационные турбины' }
  ]} />

  <!-- Hero Section -->
  <section class="hero">
    <div class="hero-content">
      <h1>Конденсационные паровые турбины</h1>
      <p>Максимальное использование энергии пара для выработки электроэнергии. Прямая конденсация, экстракционная и с двойным регулируемым отбором</p>
      <div class="hero-buttons">
        <button class="button-47" data-modal="turbine">
          <span class="button-47__circle">
            <svg class="button-47__icon-svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path class="icon-fan" d="M12 12c0-3 2.5-5 5-5 2.5 0 5 1.5 5 5s-2.5 5-5 5c-2.5 0-5-2-5-5zm0 0c0 3-2.5 5-5 5-2.5 0-5-1.5-5-5s2.5-5 5-5c2.5 0 5 2 5 5zm0 0c3 0 5-2.5 5-5 0-2.5-1.5-5-5-5-3 0-5 2.5-5 5 0 2.5 2 5 5 5zm0 0c-3 0-5 2.5-5 5 0 2.5 1.5 5 5 5 3 0 5-2.5 5-5 0-2.5-2-5-5-5z"/>
            </svg>
          </span>
          <span class="button-47__text">Подобрать решение</span>
        </button>
      </div>
    </div>
  </section>

  <!-- Introduction Section -->
  <section class="section intro">
    <div class="intro-container">
      <div class="intro-text">
        <h2>Что такое конденсационная турбина?</h2>
        <p class="lead">
          <strong>Конденсационная турбина</strong> способна максимально использовать полную энергию потока пара на входе. Отработанный пар направляется в конденсатор, где создаётся глубокий вакуум, что позволяет извлечь максимум энергии из пара.
        </p>
        <p>
          Этот тип турбин используется в энергетических компаниях, которые хотят поставлять потребителям как можно больше электроэнергии. Конденсационные турбины — основа современной тепловой энергетики.
        </p>
        <div class="intro-stats">
          <div class="stat-card">
            <div class="stat-value">4–120</div>
            <div class="stat-label">МВт мощности</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">до 42%</div>
            <div class="stat-label">КПД цикла</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">200 000+</div>
            <div class="stat-label">часов ресурса</div>
          </div>
        </div>
      </div>
      <div class="intro-visual">
        <div class="intro-image">
          <img src="/img/turbines/Осевые турбины.webp" alt="Конденсационная турбина" loading="lazy" />
        </div>
      </div>
    </div>
  </section>

  <!-- Turbine Types Section -->
  <section class="section turbine-types">
    <div class="section-header">
      <h2>Типы конденсационных турбин</h2>
      <p>Выберите оптимальную конфигурацию под ваши задачи</p>
    </div>
    
    <div class="types-grid">
      {turbineTypes.map((type, index) => (
        <div class="type-card" data-type={type.icon}>
          <div class="type-header">
            <h3>{type.title}</h3>
            <span class="type-subtitle">{type.subtitle}</span>
          </div>
          <p class="type-description">{type.description}</p>
          <ul class="type-features">
            {type.features.map(feature => (
              <li>
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <polyline points="20 6 9 17 4 12"/>
                </svg>
                {feature}
              </li>
            ))}
          </ul>
          <div class="type-image">
            <img src={type.image} alt={type.title} loading="lazy" />
          </div>
        </div>
      ))}
    </div>
  </section>

  <!-- How it Works Section -->
  <section class="section how-it-works">
    <div class="section-header">
      <h2>Принцип работы</h2>
      <p>Как конденсационная турбина преобразует энергию пара</p>
    </div>
    
    <div class="process-flow">
      <div class="process-step">
        <div class="step-icon">
          <!-- Steam input icon -->
          <svg viewBox="0 0 48 48" fill="none">
            <circle cx="24" cy="24" r="20" fill="none" stroke="currentColor" stroke-width="1.5"/>
            <path d="M12 28 Q16 20 12 14" stroke="currentColor" stroke-width="2" stroke-linecap="round" fill="none" opacity="0.7"/>
            <path d="M20 30 Q24 20 20 12" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" fill="none"/>
            <path d="M28 28 Q32 20 28 14" stroke="currentColor" stroke-width="2" stroke-linecap="round" fill="none" opacity="0.7"/>
            <path d="M32 24 L40 24" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            <path d="M36 20 L40 24 L36 28" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
        <div class="step-content">
          <h3>Подача пара</h3>
          <p>Пар высокого давления и температуры подаётся на входные сопла турбины</p>
        </div>
      </div>
      
      <div class="process-arrow">
        <svg viewBox="0 0 24 24" fill="none">
          <path d="M5 12H19M19 12L12 5M19 12L12 19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>
      
      <div class="process-step">
        <div class="step-icon">
          <!-- Turbine/expansion icon -->
          <svg viewBox="0 0 48 48" fill="none">
            <circle cx="24" cy="24" r="20" fill="none" stroke="currentColor" stroke-width="1.5"/>
            <circle cx="24" cy="24" r="5" fill="none" stroke="currentColor" stroke-width="1.5"/>
            <path d="M24 19 C24 12 30 8 30 8 C30 8 26 14 29 19" stroke="currentColor" stroke-width="2" stroke-linecap="round" fill="none"/>
            <path d="M29 24 C36 24 40 30 40 30 C40 30 34 26 29 29" stroke="currentColor" stroke-width="2" stroke-linecap="round" fill="none"/>
            <path d="M24 29 C24 36 18 40 18 40 C18 40 22 34 19 29" stroke="currentColor" stroke-width="2" stroke-linecap="round" fill="none"/>
            <path d="M19 24 C12 24 8 18 8 18 C8 18 14 22 19 19" stroke="currentColor" stroke-width="2" stroke-linecap="round" fill="none"/>
          </svg>
        </div>
        <div class="step-content">
          <h3>Расширение</h3>
          <p>Пар расширяется в проточной части, отдавая энергию лопаткам ротора</p>
        </div>
      </div>
      
      <div class="process-arrow">
        <svg viewBox="0 0 24 24" fill="none">
          <path d="M5 12H19M19 12L12 5M19 12L12 19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>
      
      <div class="process-step">
        <div class="step-icon">
          <!-- Condensation/water droplet icon -->
          <svg viewBox="0 0 48 48" fill="none">
            <circle cx="24" cy="24" r="20" fill="none" stroke="currentColor" stroke-width="1.5"/>
            <path d="M24 10 C24 10 14 22 14 28 C14 34 18 38 24 38 C30 38 34 34 34 28 C34 22 24 10 24 10Z" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
            <path d="M20 26 Q22 22 20 18" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" opacity="0.6"/>
            <path d="M18 30 C18 32 20 34 24 34" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" opacity="0.4"/>
          </svg>
        </div>
        <div class="step-content">
          <h3>Конденсация</h3>
          <p>Отработанный пар поступает в конденсатор, где превращается в воду</p>
        </div>
      </div>
      
      <div class="process-arrow">
        <svg viewBox="0 0 24 24" fill="none">
          <path d="M5 12H19M19 12L12 5M19 12L12 19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>
      
      <div class="process-step">
        <div class="step-icon">
          <!-- Electricity/generator icon -->
          <svg viewBox="0 0 48 48" fill="none">
            <circle cx="24" cy="24" r="20" fill="none" stroke="currentColor" stroke-width="1.5"/>
            <path d="M26 8 L18 24 L24 24 L22 40 L32 22 L26 22 L26 8Z" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
            <circle cx="10" cy="18" r="2" fill="currentColor" opacity="0.4"/>
            <circle cx="38" cy="30" r="2" fill="currentColor" opacity="0.4"/>
            <circle cx="14" cy="36" r="1.5" fill="currentColor" opacity="0.3"/>
            <circle cx="36" cy="14" r="1.5" fill="currentColor" opacity="0.3"/>
          </svg>
        </div>
        <div class="step-content">
          <h3>Генерация</h3>
          <p>Крутящий момент передаётся на генератор для выработки электроэнергии</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Control System Section -->
  <section class="section control-system">
    <div class="control-grid">
      <div class="control-content">
        <h2>Система управления</h2>
        <p class="control-intro">
          Система управления работает по замкнутому механизму обратной связи для точного контроля параметров пара и мощности.
        </p>
        
        <div class="control-features">
          <div class="control-feature">
            <div class="feature-icon">
              <!-- Pressure gauge icon -->
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <circle cx="12" cy="13" r="9"/>
                <path d="M12 4v2" stroke-linecap="round"/>
                <path d="M12 13l4-4" stroke-width="2" stroke-linecap="round"/>
                <circle cx="12" cy="13" r="1.5" fill="currentColor"/>
                <path d="M5.5 8.5l1 1" stroke-linecap="round"/>
                <path d="M18.5 8.5l-1 1" stroke-linecap="round"/>
                <path d="M4 13h1.5" stroke-linecap="round"/>
                <path d="M18.5 13h1.5" stroke-linecap="round"/>
                <path d="M7 18l.7-.7" stroke-linecap="round"/>
                <path d="M17 18l-.7-.7" stroke-linecap="round"/>
              </svg>
            </div>
            <div class="feature-text">
              <h4>Измерение давления</h4>
              <p>Давление на стороне потребителя измеряется и подаётся обратно в систему управления</p>
            </div>
          </div>
          
          <div class="control-feature">
            <div class="feature-icon">
              <!-- Signal/feedback loop icon -->
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M4 12h3l2-6 3 12 2.5-9 1.5 3h4" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <circle cx="19" cy="12" r="2" stroke-width="1.5"/>
                <path d="M2 12h1" stroke-linecap="round"/>
                <path d="M21 12h1" stroke-linecap="round"/>
              </svg>
            </div>
            <div class="feature-text">
              <h4>Сигнал ошибки</h4>
              <p>На основе сигнала ошибки система управления приводит в действие регулирующий клапан</p>
            </div>
          </div>
          
          <div class="control-feature">
            <div class="feature-icon">
              <!-- Valve icon -->
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M3 12h4" stroke-linecap="round"/>
                <path d="M17 12h4" stroke-linecap="round"/>
                <path d="M7 8l5 4-5 4" stroke-width="2" stroke-linejoin="round"/>
                <path d="M17 8l-5 4 5 4" stroke-width="2" stroke-linejoin="round"/>
                <line x1="12" y1="6" x2="12" y2="4" stroke-width="2" stroke-linecap="round"/>
                <circle cx="12" cy="3" r="1" fill="currentColor"/>
                <rect x="10" y="5" width="4" height="3" rx="0.5" fill="none" stroke-width="1.5"/>
              </svg>
            </div>
            <div class="feature-text">
              <h4>Регулирующие клапаны</h4>
              <p>Мембранные или проходные клапаны изменяют площадь отверстия для регулировки давления</p>
            </div>
          </div>
        </div>
      </div>
      
      <div class="control-diagram">
        <svg viewBox="0 0 340 240" fill="none" xmlns="http://www.w3.org/2000/svg">
          <!-- Blueprint background with grid -->
          <defs>
            <pattern id="smallGrid" width="10" height="10" patternUnits="userSpaceOnUse">
              <path d="M 10 0 L 0 0 0 10" fill="none" stroke="#e5e7eb" stroke-width="0.5"/>
            </pattern>
            <pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse">
              <rect width="50" height="50" fill="url(#smallGrid)"/>
              <path d="M 50 0 L 0 0 0 50" fill="none" stroke="#d1d5db" stroke-width="1"/>
            </pattern>
            <marker id="arrowGray" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto">
              <path d="M0 0 L10 5 L0 10 L2 5 Z" fill="#4b5563"/>
            </marker>
            <marker id="arrowDashed" markerWidth="8" markerHeight="8" refX="6" refY="4" orient="auto">
              <path d="M0 1 L6 4 L0 7 Z" fill="#9ca3af"/>
            </marker>
          </defs>
          
          <!-- Background -->
          <rect x="0" y="0" width="340" height="240" fill="#fafafa"/>
          <rect x="0" y="0" width="340" height="240" fill="url(#grid)"/>
          
          <!-- Border frame -->
          <rect x="8" y="8" width="324" height="224" fill="none" stroke="#374151" stroke-width="2"/>
          <rect x="12" y="12" width="316" height="216" fill="none" stroke="#9ca3af" stroke-width="0.5"/>
          
          <!-- Title block -->
          <rect x="220" y="200" width="112" height="28" fill="#f3f4f6" stroke="#6b7280" stroke-width="1"/>
          <text x="276" y="218" font-size="7" fill="#374151" text-anchor="middle" font-family="monospace">СХЕМА АСУ ТП</text>
          
          <!-- Steam input pipe -->
          <rect x="20" y="105" width="40" height="16" fill="none" stroke="#374151" stroke-width="1.5"/>
          <path d="M20 113 L30 113" stroke="#6b7280" stroke-width="1" stroke-dasharray="2 2"/>
          <text x="40" y="135" font-size="7" fill="#4b5563" text-anchor="middle" font-family="monospace">ПАР →</text>
          
          <!-- Pressure sensor (detailed) -->
          <circle cx="85" cy="113" r="22" fill="#f9fafb" stroke="#374151" stroke-width="1.5"/>
          <circle cx="85" cy="113" r="18" fill="none" stroke="#6b7280" stroke-width="0.75"/>
          <path d="M85 95 L85 99" stroke="#4b5563" stroke-width="1"/>
          <path d="M85 127 L85 131" stroke="#4b5563" stroke-width="1"/>
          <path d="M67 113 L71 113" stroke="#4b5563" stroke-width="1"/>
          <path d="M99 113 L103 113" stroke="#4b5563" stroke-width="1"/>
          <path d="M85 113 L95 103" stroke="#1f2937" stroke-width="2" stroke-linecap="round"/>
          <circle cx="85" cy="113" r="3" fill="#374151"/>
          <text x="85" y="118" font-size="8" fill="#374151" text-anchor="middle" font-weight="bold">P</text>
          <text x="85" y="150" font-size="8" fill="#4b5563" text-anchor="middle" font-family="monospace">PT-101</text>
          <text x="85" y="160" font-size="6" fill="#6b7280" text-anchor="middle">Датчик давления</text>
          
          <!-- Signal line to controller -->
          <path d="M107 113 L140 113" stroke="#374151" stroke-width="1.5" marker-end="url(#arrowGray)"/>
          <text x="123" y="108" font-size="6" fill="#6b7280" text-anchor="middle">4-20мА</text>
          
          <!-- PLC Controller (detailed) -->
          <rect x="145" y="85" width="70" height="56" fill="#f3f4f6" stroke="#374151" stroke-width="1.5"/>
          <rect x="148" y="88" width="64" height="50" fill="none" stroke="#9ca3af" stroke-width="0.5"/>
          <!-- Controller details -->
          <rect x="152" y="92" width="12" height="8" fill="#e5e7eb" stroke="#6b7280" stroke-width="0.5"/>
          <rect x="167" y="92" width="12" height="8" fill="#e5e7eb" stroke="#6b7280" stroke-width="0.5"/>
          <rect x="182" y="92" width="12" height="8" fill="#e5e7eb" stroke="#6b7280" stroke-width="0.5"/>
          <rect x="197" y="92" width="12" height="8" fill="#e5e7eb" stroke="#6b7280" stroke-width="0.5"/>
          <circle cx="158" cy="110" r="2" fill="#4ade80"/>
          <circle cx="165" cy="110" r="2" fill="#facc15"/>
          <circle cx="172" cy="110" r="2" fill="#f87171"/>
          <rect x="152" y="118" width="56" height="14" fill="#1f2937" stroke="#374151" stroke-width="0.5"/>
          <text x="180" y="128" font-size="7" fill="#22c55e" text-anchor="middle" font-family="monospace">RUN</text>
          <text x="180" y="155" font-size="8" fill="#4b5563" text-anchor="middle" font-family="monospace">PLC-01</text>
          <text x="180" y="165" font-size="6" fill="#6b7280" text-anchor="middle">Контроллер</text>
          
          <!-- Signal line to valve -->
          <path d="M220 113 L250 113" stroke="#374151" stroke-width="1.5" marker-end="url(#arrowGray)"/>
          <text x="235" y="108" font-size="6" fill="#6b7280" text-anchor="middle">0-10В</text>
          
          <!-- Control valve (detailed) -->
          <path d="M255 98 L275 113 L255 128 Z" fill="#f9fafb" stroke="#374151" stroke-width="1.5"/>
          <path d="M275 98 L255 113 L275 128 Z" fill="#f9fafb" stroke="#374151" stroke-width="1.5"/>
          <line x1="265" y1="98" x2="265" y2="78" stroke="#374151" stroke-width="2"/>
          <rect x="258" y="68" width="14" height="12" fill="#e5e7eb" stroke="#374151" stroke-width="1"/>
          <line x1="265" y1="68" x2="265" y2="62" stroke="#374151" stroke-width="1.5"/>
          <circle cx="265" cy="60" r="4" fill="none" stroke="#374151" stroke-width="1"/>
          <text x="265" y="150" font-size="8" fill="#4b5563" text-anchor="middle" font-family="monospace">CV-101</text>
          <text x="265" y="160" font-size="6" fill="#6b7280" text-anchor="middle">Рег. клапан</text>
          
          <!-- Output pipe -->
          <rect x="280" y="105" width="40" height="16" fill="none" stroke="#374151" stroke-width="1.5"/>
          <path d="M290 113 L310 113" stroke="#6b7280" stroke-width="1" stroke-dasharray="2 2"/>
          <text x="300" y="135" font-size="7" fill="#4b5563" text-anchor="middle" font-family="monospace">→ ТУРБ</text>
          
          <!-- Feedback loop -->
          <path d="M180 80 L180 45 L85 45 L85 90" stroke="#9ca3af" stroke-width="1" stroke-dasharray="4 2" marker-end="url(#arrowDashed)"/>
          <rect x="110" y="38" width="50" height="14" fill="#fafafa" stroke="none"/>
          <text x="135" y="48" font-size="7" fill="#6b7280" text-anchor="middle" font-family="monospace">ОБРАТНАЯ</text>
          <text x="135" y="56" font-size="7" fill="#6b7280" text-anchor="middle" font-family="monospace">СВЯЗЬ</text>
          
          <!-- Setpoint indicator -->
          <rect x="145" y="170" width="70" height="20" fill="none" stroke="#9ca3af" stroke-width="1" stroke-dasharray="3 2"/>
          <text x="180" y="183" font-size="7" fill="#6b7280" text-anchor="middle" font-family="monospace">SP = var</text>
          <path d="M180 170 L180 145" stroke="#9ca3af" stroke-width="0.75" stroke-dasharray="2 2"/>
        </svg>
      </div>
    </div>
  </section>

  <!-- Technical Features Section with 3D Turbine -->
  <section class="section tech-features-infographic">
    <div class="turbine-3d-container" id="turbine-canvas"></div>
    
    <div class="tech-features-content">
      <div class="section-header">
        <h2>Технические характеристики</h2>
        <p>Высокоэффективные решения для энергетических объектов</p>
      </div>
      
      <div class="tech-features-cards">
        <div class="infographic-card">
          <div class="card-icon">
            <svg viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M24 4L4 14V34L24 44L44 34V14L24 4Z" stroke="currentColor" stroke-width="2"/>
              <path d="M24 18L14 23V33L24 38L34 33V23L24 18Z" fill="currentColor" opacity="0.2"/>
              <circle cx="24" cy="24" r="6" stroke="currentColor" stroke-width="2"/>
            </svg>
          </div>
          <h3>Многоступенчатая конструкция</h3>
          <p>Оптимальное распределение теплоперепада по ступеням для максимального КПД</p>
        </div>
        
        <div class="infographic-card">
          <div class="card-icon">
            <svg viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
              <circle cx="24" cy="24" r="18" stroke="currentColor" stroke-width="2"/>
              <path d="M24 12V24L32 28" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              <path d="M38 24C38 31.732 31.732 38 24 38" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
            </svg>
          </div>
          <h3>Глубокий вакуум</h3>
          <p>Конденсатор создаёт вакуум до 0.03 бар для максимального использования энергии</p>
        </div>
        
        <div class="infographic-card">
          <div class="card-icon">
            <svg viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M24 4L6 12V24C6 35 24 44 24 44C24 44 42 35 42 24V12L24 4Z" stroke="currentColor" stroke-width="2"/>
              <path d="M17 24L22 29L31 20" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
          <h3>Регулируемый отбор</h3>
          <p>Автоматическое поддержание давления отбора с точностью ±0.5%</p>
        </div>
        
        <div class="infographic-card">
          <div class="card-icon">
            <svg viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
              <rect x="8" y="14" width="32" height="20" rx="2" stroke="currentColor" stroke-width="2"/>
              <path d="M16 22V26M24 20V28M32 22V26" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
          </div>
          <h3>Осевой выхлоп</h3>
          <p>Выходной патрубок параллелен оси ротора для подключения поверхностного конденсатора</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Advantages Section -->
  <section class="section advantages">
    <div class="section-header">
      <h2>Ключевые преимущества</h2>
      <p>Конденсационные турбины — оптимальный выбор для максимальной генерации</p>
    </div>
    <div class="advantages-grid-new">
      {advantages.map((advantage, index) => (
        <div class="advantage-card-new" style={`--delay: ${index * 0.1}s`}>
          <div class="advantage-header">
            <div class="advantage-icon-new">
              <img src={advantage.icon} alt={advantage.title} />
            </div>
            <div class="advantage-stat">
              <span class="stat-number">{advantage.stat}</span>
              <span class="stat-unit">{advantage.unit}</span>
            </div>
          </div>
          <div class="advantage-body">
            <h3>{advantage.title}</h3>
            <p>{advantage.description}</p>
          </div>
          <div class="advantage-glow"></div>
        </div>
      ))}
    </div>
  </section>

  <Faq items={faqItems} />

  <CtaFaq />
</BaseLayout>

<style>
  /* Hero Section */
  .hero {
    background: linear-gradient(135deg, rgba(42, 45, 46, 0.9) 0%, rgba(0, 0, 0, 0.7) 100%), 
                url('/img/metal_gears_fixed_bolts.webp') center/cover no-repeat;
    border-radius: var(--radius-xl);
    padding: var(--space-16) var(--space-8);
    margin-bottom: var(--space-12);
    min-height: 450px;
    display: flex;
    align-items: center;
  }

  .hero-content {
    max-width: 700px;
    color: var(--color-white);
  }

  .hero h1 {
    font-size: clamp(36px, 6vw, 56px);
    color: var(--color-white);
    margin-bottom: var(--space-4);
    letter-spacing: -1px;
    line-height: 1.1;
  }

  .hero p {
    font-size: var(--text-lg);
    opacity: 0.9;
    line-height: 1.7;
    max-width: 600px;
    margin-bottom: var(--space-8);
  }

  /* Section Styles */
  .section {
    margin-bottom: var(--space-12);
  }

  .section-header {
    margin-bottom: var(--space-8);
  }

  .section-header h2 {
    font-size: var(--text-3xl);
    color: var(--color-primary);
    margin-bottom: var(--space-2);
  }

  .section-header p {
    font-size: var(--text-lg);
    color: var(--color-text-muted);
    max-width: 600px;
  }

  /* Intro Section */
  .intro-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-8);
    align-items: center;
  }

  @media (max-width: 1024px) {
    .intro-container {
      grid-template-columns: 1fr;
    }
  }

  .intro-text h2 {
    font-size: var(--text-3xl);
    color: var(--color-primary);
    margin-bottom: var(--space-4);
  }

  .intro-text .lead {
    font-size: var(--text-lg);
    line-height: 1.8;
    color: var(--color-text);
    margin-bottom: var(--space-4);
  }

  .intro-text .lead strong {
    color: var(--color-primary);
  }

  .intro-text p {
    color: var(--color-text-muted);
    line-height: 1.7;
  }

  .intro-text .intro-stats {
    margin-top: var(--space-6);
  }

  .intro-visual {
    display: flex;
    flex-direction: column;
    gap: var(--space-6);
  }

  .intro-image {
    border-radius: var(--radius-xl);
    overflow: hidden;
    box-shadow: 0 8px 32px rgba(14, 165, 233, 0.15);
  }

  .intro-image img {
    width: 100%;
    height: auto;
    display: block;
    transition: transform 0.4s ease;
  }

  .intro-image:hover img {
    transform: scale(1.02);
  }

  .intro-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--space-4);
  }

  @media (max-width: 640px) {
    .intro-stats {
      grid-template-columns: 1fr;
    }
  }

  .stat-card {
    background: linear-gradient(135deg, rgba(14, 165, 233, 0.08) 0%, rgba(56, 189, 248, 0.04) 100%);
    border: 1px solid rgba(14, 165, 233, 0.15);
    border-radius: var(--radius-xl);
    padding: var(--space-6);
    text-align: center;
  }

  .stat-value {
    font-size: var(--text-3xl);
    font-weight: 800;
    color: rgb(14, 165, 233);
    font-family: var(--font-heading);
  }

  .stat-label {
    font-size: var(--text-sm);
    color: var(--color-text-muted);
    margin-top: var(--space-2);
  }

  /* Turbine Types Section */
  .types-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--space-6);
  }

  @media (max-width: 1024px) {
    .types-grid {
      grid-template-columns: 1fr;
    }
  }

  .type-card {
    position: relative;
    background: white;
    border-radius: var(--radius-xl);
    padding: var(--space-8);
    border: 1px solid rgba(14, 165, 233, 0.1);
    overflow: hidden;
  }

  .type-header {
    margin-bottom: var(--space-4);
  }

  .type-header h3 {
    font-size: var(--text-xl);
    color: var(--color-primary);
    margin-bottom: var(--space-1);
  }

  .type-subtitle {
    font-size: var(--text-sm);
    color: rgb(14, 165, 233);
    font-weight: 500;
  }

  .type-description {
    font-size: var(--text-base);
    color: var(--color-text-muted);
    line-height: 1.7;
    margin-bottom: var(--space-4);
  }

  .type-features {
    list-style: none;
    padding: 0;
    margin: 0 0 var(--space-6) 0;
  }

  .type-features li {
    display: flex;
    align-items: center;
    gap: var(--space-2);
    font-size: var(--text-sm);
    color: var(--color-text);
    margin-bottom: var(--space-2);
  }

  .type-features li svg {
    color: rgb(14, 165, 233);
    flex-shrink: 0;
  }

  .type-image {
    margin-top: var(--space-4);
    border-radius: var(--radius-lg);
    overflow: hidden;
  }

  .type-image img {
    width: 100%;
    height: auto;
    border-radius: var(--radius-lg);
  }

  /* Process Flow */
  .process-flow {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--space-4);
    flex-wrap: wrap;
  }

  @media (max-width: 1024px) {
    .process-flow {
      flex-direction: column;
    }
  }

  .process-step {
    position: relative;
    flex: 1;
    min-width: 200px;
    background: white;
    border-radius: var(--radius-xl);
    padding: var(--space-6);
    border: 1px solid rgba(14, 165, 233, 0.1);
    text-align: center;
  }

  .step-icon {
    width: 64px;
    height: 64px;
    margin: 0 auto var(--space-4);
    color: rgb(14, 165, 233);
  }

  .step-icon svg {
    width: 100%;
    height: 100%;
  }

  .step-content h3 {
    font-size: var(--text-lg);
    color: var(--color-primary);
    margin-bottom: var(--space-2);
  }

  .step-content p {
    font-size: var(--text-sm);
    color: var(--color-text-muted);
    line-height: 1.6;
  }

  .process-arrow {
    width: 32px;
    height: 32px;
    color: rgba(14, 165, 233, 0.4);
    flex-shrink: 0;
  }

  @media (max-width: 1024px) {
    .process-arrow {
      transform: rotate(90deg);
    }
  }

  /* Control System Section */
  .control-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-8);
    align-items: center;
    background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
    border-radius: var(--radius-xl);
    padding: var(--space-10);
  }

  @media (max-width: 1024px) {
    .control-grid {
      grid-template-columns: 1fr;
    }
  }

  .control-content h2 {
    font-size: var(--text-3xl);
    color: var(--color-primary);
    margin-bottom: var(--space-4);
  }

  .control-intro {
    font-size: var(--text-lg);
    color: var(--color-text);
    line-height: 1.7;
    margin-bottom: var(--space-6);
  }

  .control-features {
    display: flex;
    flex-direction: column;
    gap: var(--space-4);
  }

  .control-feature {
    display: flex;
    gap: var(--space-4);
    padding: var(--space-4);
    background: white;
    border-radius: var(--radius-lg);
    transition: all 0.3s ease;
  }

  .control-feature:hover {
    transform: translateX(8px);
    box-shadow: 0 4px 12px rgba(14, 165, 233, 0.1);
  }

  .feature-icon {
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, rgba(14, 165, 233, 0.1) 0%, rgba(56, 189, 248, 0.05) 100%);
    border-radius: var(--radius-md);
    color: rgb(14, 165, 233);
    flex-shrink: 0;
  }

  .feature-icon svg {
    width: 24px;
    height: 24px;
  }

  .feature-text h4 {
    font-size: var(--text-base);
    color: var(--color-primary);
    margin-bottom: var(--space-1);
  }

  .feature-text p {
    font-size: var(--text-sm);
    color: var(--color-text-muted);
    line-height: 1.5;
  }

  .control-diagram {
    background: white;
    border-radius: var(--radius-xl);
    padding: var(--space-6);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
  }

  .control-diagram svg {
    width: 100%;
    height: auto;
  }

  /* Technical Features Infographic Section */
  .tech-features-infographic {
    position: relative;
    min-height: 700px;
    overflow: hidden;
    border-radius: var(--radius-xl);
  }
  
  .tech-features-content {
    position: relative;
    z-index: 2;
    padding: var(--space-8);
  }
  
  .tech-features-content .section-header {
    margin-bottom: var(--space-6);
  }
  
  .tech-features-content .section-header h2,
  .tech-features-content .section-header p {
    text-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  }
  
  .tech-features-cards {
    display: flex;
    flex-direction: column;
    gap: var(--space-4);
    max-width: 420px;
  }

  @keyframes windSway {
    0%, 100% { transform: translateX(0) rotate(0deg); }
    25% { transform: translateX(-3px) rotate(-0.3deg); }
    50% { transform: translateX(-5px) rotate(-0.5deg); }
    75% { transform: translateX(-2px) rotate(-0.2deg); }
  }
  
  .infographic-card {
    background: rgba(255, 255, 255, 0.92);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(255, 255, 255, 0.5);
    border-radius: var(--radius-xl);
    padding: var(--space-5);
    position: relative;
    transition: box-shadow 0.4s ease, border-color 0.4s ease;
    overflow: hidden;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    animation: windSway 3s ease-in-out infinite;
  }
  
  .infographic-card:nth-child(1) { animation-delay: 0s; }
  .infographic-card:nth-child(2) { animation-delay: 0.4s; }
  .infographic-card:nth-child(3) { animation-delay: 0.8s; }
  .infographic-card:nth-child(4) { animation-delay: 1.2s; }

  .infographic-card:hover {
    animation-play-state: paused;
    transform: translateX(-5px) rotate(-0.3deg);
    box-shadow: 0 20px 40px rgba(163, 218, 243, 0.2), 0 10px 20px rgba(0, 0, 0, 0.1);
    border-color: var(--color-accent);
  }
  
  .card-icon {
    width: 44px;
    height: 44px;
    color: var(--color-primary);
    margin-bottom: var(--space-3);
    transition: all 0.3s ease;
  }
  
  .card-icon svg {
    width: 100%;
    height: 100%;
  }
  
  .infographic-card:hover .card-icon {
    color: var(--color-accent);
    transform: scale(1.1);
  }
  
  .infographic-card h3 {
    font-size: var(--text-md);
    font-weight: 700;
    color: var(--color-primary);
    margin-bottom: var(--space-2);
    line-height: 1.3;
  }
  
  .infographic-card p {
    font-size: var(--text-sm);
    color: var(--color-text-muted);
    line-height: 1.5;
    margin: 0;
  }
  
  .turbine-3d-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    background: transparent;
  }
  
  .turbine-3d-container canvas {
    width: 100% !important;
    height: 100% !important;
    display: block;
  }

  @media (max-width: 1200px) {
    .tech-features-infographic { min-height: 650px; }
    .tech-features-cards { max-width: 380px; }
  }

  @media (max-width: 1024px) {
    .tech-features-infographic { min-height: 750px; }
    .tech-features-cards {
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
      max-width: 320px;
    }
    .infographic-card:hover { transform: translateY(-4px); }
  }

  @media (max-width: 768px) {
    .tech-features-infographic { min-height: 700px; padding-bottom: var(--space-6); }
    .tech-features-content { padding: var(--space-4); }
    .tech-features-cards {
      max-width: 260px;
    }
    .infographic-card { 
      padding: var(--space-3) var(--space-4);
      animation: none;
    }
    .infographic-card h3 {
      font-size: var(--text-sm);
      margin-bottom: 4px;
    }
    .infographic-card p {
      font-size: 12px;
      line-height: 1.4;
    }
    .card-icon { 
      width: 32px; 
      height: 32px;
      margin-bottom: var(--space-2);
    }
  }

  @media (max-width: 480px) {
    .tech-features-infographic { min-height: 650px; }
    .tech-features-content { padding: var(--space-3); }
    .tech-features-cards {
      max-width: 220px;
      gap: var(--space-2);
    }
    .infographic-card { 
      padding: var(--space-3);
      border-radius: var(--radius-md);
    }
    .infographic-card h3 { font-size: 13px; }
    .infographic-card p {
      font-size: 11px;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .card-icon { 
      width: 28px; 
      height: 28px;
      margin-bottom: var(--space-1);
    }
  }

  /* Advantages Section */
  .advantages-grid-new {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: var(--space-4);
  }

  @media (max-width: 1200px) {
    .advantages-grid-new {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  @media (max-width: 640px) {
    .advantages-grid-new {
      grid-template-columns: 1fr;
    }
  }

  .advantage-card-new {
    position: relative;
    background: white;
    border-radius: 20px;
    padding: var(--space-6);
    border: 1px solid rgba(14, 165, 233, 0.1);
    overflow: hidden;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    animation: fadeInUp 0.6s ease forwards;
    animation-delay: var(--delay);
    opacity: 0;
  }

  @keyframes fadeInUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .advantage-card-new:hover {
    transform: translateY(-8px);
    box-shadow: 
      0 20px 40px rgba(14, 165, 233, 0.15),
      0 0 0 1px rgba(14, 165, 233, 0.2);
  }

  .advantage-card-new:hover .advantage-glow {
    opacity: 1;
  }

  .advantage-card-new:hover .advantage-icon-new {
    transform: scale(1.1) rotate(5deg);
    background: linear-gradient(135deg, rgb(14, 165, 233) 0%, rgb(56, 189, 248) 100%);
  }

  .advantage-card-new:hover .advantage-icon-new img {
    filter: brightness(0) invert(1);
  }

  .advantage-glow {
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle at center, rgba(14, 165, 233, 0.1) 0%, transparent 50%);
    opacity: 0;
    transition: opacity 0.4s ease;
    pointer-events: none;
  }

  .advantage-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: var(--space-4);
  }

  .advantage-icon-new {
    width: 56px;
    height: 56px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, rgba(14, 165, 233, 0.1) 0%, rgba(56, 189, 248, 0.05) 100%);
    border-radius: 16px;
    transition: all 0.4s ease;
  }

  .advantage-icon-new img {
    width: 28px;
    height: 28px;
    object-fit: contain;
    transition: all 0.3s ease;
  }

  .advantage-stat {
    text-align: right;
  }

  .stat-number {
    display: block;
    font-size: var(--text-2xl);
    font-weight: 800;
    color: rgb(14, 165, 233);
    line-height: 1;
    font-family: var(--font-heading);
  }

  .stat-unit {
    font-size: var(--text-xs);
    color: var(--color-text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .advantage-body h3 {
    font-size: var(--text-base);
    font-weight: 700;
    color: var(--color-primary);
    margin-bottom: var(--space-2);
    line-height: 1.3;
  }

  .advantage-body p {
    font-size: var(--text-sm);
    color: var(--color-text-muted);
    line-height: 1.6;
    margin: 0;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .hero {
      padding: var(--space-10) var(--space-5);
      min-height: 400px;
    }

    .control-grid {
      padding: var(--space-6);
    }
  }
</style>

<script>
  // 3D Condensing Turbine with multiple stages
  async function init3DTurbine() {
    const container = document.getElementById('turbine-canvas');
    if (!container) return;
    
    const THREE = await import('https://unpkg.com/three@0.153.0/build/three.module.js');
    const { OrbitControls } = await import('https://unpkg.com/three@0.153.0/examples/jsm/controls/OrbitControls.js');
    const { GPUComputationRenderer } = await import('https://unpkg.com/three@0.153.0/examples/jsm/misc/GPUComputationRenderer.js');
    
    const scene = new THREE.Scene();
    scene.background = null;
    
    const width = container.clientWidth;
    const height = container.clientHeight;
    
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    renderer.setClearColor(0x000000, 0);
    container.appendChild(renderer.domElement);
    
    const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
    camera.position.set(0, 3, 14);
    camera.lookAt(0, 0, 0);
    
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0, 0);
    controls.enableZoom = false;
    controls.enablePan = false;
    
    const isMobile = width < 400;
    scene.position.x = isMobile ? 4 - 0.75 : 4;
    scene.rotation.y = Math.PI;
    scene.scale.setScalar(1.5);
    
    // Steel Materials Library
    const steelMaterials = {
      polishedSteel: new THREE.MeshStandardMaterial({
        color: 0xB0B0B0,
        metalness: 0.6,
        roughness: 0.25
      }),
      brushedSteel: new THREE.MeshStandardMaterial({
        color: 0x909090,
        metalness: 0.5,
        roughness: 0.4
      }),
      darkSteel: new THREE.MeshStandardMaterial({
        color: 0x606060,
        metalness: 0.4,
        roughness: 0.5
      }),
      bladeSteel: new THREE.MeshStandardMaterial({
        color: 0xA8A8A8,
        metalness: 0.55,
        roughness: 0.3
      }),
      chromeSteel: new THREE.MeshStandardMaterial({
        color: 0xC8C8C8,
        metalness: 0.7,
        roughness: 0.15
      })
    };
    
    // Lighting
    const ambient = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambient);
    
    const keyLight = new THREE.DirectionalLight(0xffffff, 2.0);
    keyLight.position.set(8, 12, 10);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048;
    keyLight.shadow.mapSize.height = 2048;
    scene.add(keyLight);
    
    const fillLight = new THREE.DirectionalLight(0xaabbcc, 1.0);
    fillLight.position.set(-8, 4, -6);
    scene.add(fillLight);
    
    const rimLight = new THREE.DirectionalLight(0xccddff, 1.2);
    rimLight.position.set(-3, -3, 8);
    scene.add(rimLight);
    
    const topLight = new THREE.DirectionalLight(0xffffff, 0.8);
    topLight.position.set(0, 15, 0);
    scene.add(topLight);
    
    const backLight = new THREE.DirectionalLight(0xffffff, 0.6);
    backLight.position.set(0, 5, -10);
    scene.add(backLight);
    
    function createTurbineStage(params) {
      const group = new THREE.Group();
      group.position.x = params.xOffset;
      
      const discGeometry = new THREE.CylinderGeometry(params.radius, params.radius * 0.95, params.thickness, 128);
      discGeometry.rotateZ(Math.PI / 2);
      const discMesh = new THREE.Mesh(discGeometry, steelMaterials.brushedSteel.clone());
      discMesh.castShadow = true;
      discMesh.receiveShadow = true;
      group.add(discMesh);
      
      const hubRingGeo = new THREE.TorusGeometry(params.radius * 0.4, 0.05, 16, 64);
      hubRingGeo.rotateY(Math.PI / 2);
      const hubRingMesh = new THREE.Mesh(hubRingGeo, steelMaterials.chromeSteel);
      hubRingMesh.position.x = params.thickness / 2 + 0.02;
      group.add(hubRingMesh);
      
      const hubRingMesh2 = hubRingMesh.clone();
      hubRingMesh2.position.x = -params.thickness / 2 - 0.02;
      group.add(hubRingMesh2);
      
      const boltCount = 12;
      for (let i = 0; i < boltCount; i++) {
        const angle = (2 * Math.PI * i) / boltCount;
        const boltRadius = params.radius * 0.7;
        
        const boltGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.08, 8);
        boltGeo.rotateZ(Math.PI / 2);
        const boltMesh = new THREE.Mesh(boltGeo, steelMaterials.chromeSteel);
        boltMesh.position.set(
          params.thickness / 2 + 0.04,
          Math.cos(angle) * boltRadius,
          Math.sin(angle) * boltRadius
        );
        group.add(boltMesh);
        
        const boltHeadGeo = new THREE.CylinderGeometry(0.045, 0.045, 0.02, 6);
        boltHeadGeo.rotateZ(Math.PI / 2);
        const boltHeadMesh = new THREE.Mesh(boltHeadGeo, steelMaterials.darkSteel);
        boltHeadMesh.position.set(
          params.thickness / 2 + 0.09,
          Math.cos(angle) * boltRadius,
          Math.sin(angle) * boltRadius
        );
        group.add(boltHeadMesh);
      }
      
      for (let i = 0; i < params.bladeCount; i++) {
        const angle = (2 * Math.PI * i) / params.bladeCount;
        
        const bladeGeo = new THREE.BoxGeometry(params.bladeThickness, params.bladeLength, params.bladeWidth);
        
        const bladeMat = (i % 3 === 0) ? steelMaterials.bladeSteel.clone() : 
                         (i % 3 === 1) ? steelMaterials.polishedSteel.clone() : 
                         steelMaterials.brushedSteel.clone();
        
        const bladeMesh = new THREE.Mesh(bladeGeo, bladeMat);
        bladeMesh.castShadow = true;
        bladeMesh.receiveShadow = true;
        
        const radial = new THREE.Vector3(0, Math.cos(angle), Math.sin(angle));
        const offset = params.radius + params.bladeLength / 2;
        bladeMesh.position.copy(radial.clone().multiplyScalar(offset));
        
        const quaternion = new THREE.Quaternion();
        quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), radial);
        bladeMesh.quaternion.copy(quaternion);
        
        group.add(bladeMesh);
      }
      
      return group;
    }
    
    const stages = [
      { radius: 2.2, thickness: 0.4, bladeCount: 52, bladeLength: 0.85, bladeWidth: 0.12, bladeThickness: 0.08, xOffset: -1.4 },
      { radius: 2.0, thickness: 0.38, bladeCount: 48, bladeLength: 0.75, bladeWidth: 0.11, bladeThickness: 0.07, xOffset: 0.0 },
      { radius: 1.8, thickness: 0.35, bladeCount: 44, bladeLength: 0.65, bladeWidth: 0.10, bladeThickness: 0.065, xOffset: 1.2 },
    ];
    
    const totalLength = stages[stages.length - 1].xOffset - stages[0].xOffset + 2.5;
    const shaftGroup = new THREE.Group();
    
    const shaftGeo = new THREE.CylinderGeometry(0.45, 0.45, totalLength, 64);
    shaftGeo.rotateZ(Math.PI / 2);
    const shaftMesh = new THREE.Mesh(shaftGeo, steelMaterials.polishedSteel);
    shaftMesh.castShadow = true;
    shaftMesh.receiveShadow = true;
    shaftMesh.position.x = (stages[0].xOffset + stages[stages.length - 1].xOffset) / 2;
    shaftGroup.add(shaftMesh);
    
    const journalPositions = [-2.0, 2.0];
    journalPositions.forEach(pos => {
      const journalGeo = new THREE.CylinderGeometry(0.52, 0.52, 0.3, 32);
      journalGeo.rotateZ(Math.PI / 2);
      const journalMesh = new THREE.Mesh(journalGeo, steelMaterials.chromeSteel);
      journalMesh.position.x = pos;
      journalMesh.castShadow = true;
      shaftGroup.add(journalMesh);
      
      const ringGeo = new THREE.TorusGeometry(0.53, 0.03, 12, 32);
      ringGeo.rotateY(Math.PI / 2);
      const ringMesh1 = new THREE.Mesh(ringGeo, steelMaterials.darkSteel);
      ringMesh1.position.x = pos + 0.15;
      shaftGroup.add(ringMesh1);
      const ringMesh2 = ringMesh1.clone();
      ringMesh2.position.x = pos - 0.15;
      shaftGroup.add(ringMesh2);
    });
    
    stages.forEach((stage, idx) => {
      if (idx < stages.length - 1) {
        const midX = (stage.xOffset + stages[idx + 1].xOffset) / 2;
        const grooveGeo = new THREE.TorusGeometry(0.46, 0.02, 8, 32);
        grooveGeo.rotateY(Math.PI / 2);
        const grooveMesh = new THREE.Mesh(grooveGeo, steelMaterials.darkSteel);
        grooveMesh.position.x = midX;
        shaftGroup.add(grooveMesh);
      }
    });
    
    scene.add(shaftGroup);
    
    const stageGroups = [];
    stages.forEach((params, idx) => {
      const stageGroup = createTurbineStage(params);
      stageGroup.userData.isRotatingStage = true;
      stageGroup.userData.stageIndex = idx;
      scene.add(stageGroup);
      stageGroups.push(stageGroup);
    });
    
    const simplexNoiseDerivatives4 = `
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
float mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
float permute(float x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
float taylorInvSqrt(float r) { return 1.79284291400159 - 0.85373472095314 * r; }
vec4 grad4(float j, vec4 ip) {
  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
  vec4 p,s;
  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
  s = vec4(lessThan(p, vec4(0.0)));
  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;
  return p;
}
#define F4 0.309016994374947451
vec4 snoise4(vec4 v) {
  const vec4 C = vec4(0.138196601125011, 0.276393202250021, 0.414589803375032, -0.447213595499958);
  vec4 i = floor(v + dot(v, vec4(F4)));
  vec4 x0 = v - i + dot(i, C.xxxx);
  vec4 i0;
  vec3 isX = step(x0.yzw, x0.xxx);
  vec3 isYZ = step(x0.zww, x0.yyz);
  i0.x = isX.x + isX.y + isX.z;
  i0.yzw = 1.0 - isX;
  i0.y += isYZ.x + isYZ.y;
  i0.zw += 1.0 - isYZ.xy;
  i0.z += isYZ.z;
  i0.w += 1.0 - isYZ.z;
  vec4 i3 = clamp(i0, 0.0, 1.0);
  vec4 i2 = clamp(i0 - 1.0, 0.0, 1.0);
  vec4 i1 = clamp(i0 - 2.0, 0.0, 1.0);
  vec4 x1 = x0 - i1 + C.xxxx;
  vec4 x2 = x0 - i2 + C.yyyy;
  vec4 x3 = x0 - i3 + C.zzzz;
  vec4 x4 = x0 + C.wwww;
  i = mod289(i);
  float j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x);
  vec4 j1 = permute(permute(permute(permute(i.w + vec4(i1.w, i2.w, i3.w, 1.0)) + i.z + vec4(i1.z, i2.z, i3.z, 1.0)) + i.y + vec4(i1.y, i2.y, i3.y, 1.0)) + i.x + vec4(i1.x, i2.x, i3.x, 1.0));
  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0);
  vec4 p0 = grad4(j0, ip);
  vec4 p1 = grad4(j1.x, ip);
  vec4 p2 = grad4(j1.y, ip);
  vec4 p3 = grad4(j1.z, ip);
  vec4 p4 = grad4(j1.w, ip);
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
  p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
  p4 *= taylorInvSqrt(dot(p4,p4));
  vec3 values0 = vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2));
  vec2 values1 = vec2(dot(p3, x3), dot(p4, x4));
  vec3 m0 = max(0.5 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
  vec2 m1 = max(0.5 - vec2(dot(x3,x3), dot(x4,x4)), 0.0);
  vec3 temp0 = -6.0 * m0 * m0 * values0;
  vec2 temp1 = -6.0 * m1 * m1 * values1;
  vec3 mmm0 = m0 * m0 * m0;
  vec2 mmm1 = m1 * m1 * m1;
  float dx = temp0[0] * x0.x + temp0[1] * x1.x + temp0[2] * x2.x + temp1[0] * x3.x + temp1[1] * x4.x + mmm0[0] * p0.x + mmm0[1] * p1.x + mmm0[2] * p2.x + mmm1[0] * p3.x + mmm1[1] * p4.x;
  float dy = temp0[0] * x0.y + temp0[1] * x1.y + temp0[2] * x2.y + temp1[0] * x3.y + temp1[1] * x4.y + mmm0[0] * p0.y + mmm0[1] * p1.y + mmm0[2] * p2.y + mmm1[0] * p3.y + mmm1[1] * p4.y;
  float dz = temp0[0] * x0.z + temp0[1] * x1.z + temp0[2] * x2.z + temp1[0] * x3.z + temp1[1] * x4.z + mmm0[0] * p0.z + mmm0[1] * p1.z + mmm0[2] * p2.z + mmm1[0] * p3.z + mmm1[1] * p4.z;
  float dw = temp0[0] * x0.w + temp0[1] * x1.w + temp0[2] * x2.w + temp1[0] * x3.w + temp1[1] * x4.w + mmm0[0] * p0.w + mmm0[1] * p1.w + mmm0[2] * p2.w + mmm1[0] * p3.w + mmm1[1] * p4.w;
  return vec4(dx, dy, dz, dw) * 49.0;
}
`;

    const curlNoise = `
${simplexNoiseDerivatives4}
vec3 curl(vec3 p, float noiseTime, float persistence) {
  vec4 xNoisePotentialDerivatives = vec4(0.0);
  vec4 yNoisePotentialDerivatives = vec4(0.0);
  vec4 zNoisePotentialDerivatives = vec4(0.0);
  for (int i = 0; i < 3; ++i) {
    float twoPowI = pow(2.0, float(i));
    float scale = 0.5 * twoPowI * pow(persistence, float(i));
    xNoisePotentialDerivatives += snoise4(vec4(p * twoPowI, noiseTime)) * scale;
    yNoisePotentialDerivatives += snoise4(vec4((p + vec3(123.4, 129845.6, -1239.1)) * twoPowI, noiseTime)) * scale;
    zNoisePotentialDerivatives += snoise4(vec4((p + vec3(-9519.0, 9051.0, -123.0)) * twoPowI, noiseTime)) * scale;
  }
  return vec3(
    zNoisePotentialDerivatives[1] - yNoisePotentialDerivatives[2],
    xNoisePotentialDerivatives[2] - zNoisePotentialDerivatives[0],
    yNoisePotentialDerivatives[0] - xNoisePotentialDerivatives[1]
  );
}
`;

    const PARTICLE_COUNT = 90;
    const gpuCompute = new GPUComputationRenderer(PARTICLE_COUNT, PARTICLE_COUNT, renderer);
    
    const dtPosition = gpuCompute.createTexture();
    const dtDefaultPosition = gpuCompute.createTexture();
    
    const posArray = dtPosition.image.data;
    const defaultPosArray = dtDefaultPosition.image.data;
    
    for (let i = 0; i < posArray.length; i += 4) {
      defaultPosArray[i] = Math.random();
      defaultPosArray[i + 1] = Math.random();
      defaultPosArray[i + 2] = Math.random();
      defaultPosArray[i + 3] = Math.random();
      
      const angle = defaultPosArray[i + 3] * Math.PI * 2;
      const radius = 2.5 + defaultPosArray[i] * 0.8;
      const axial = defaultPosArray[i + 1] * 2.3 - 1.15;
      
      posArray[i] = axial;
      posArray[i + 1] = Math.cos(angle) * radius;
      posArray[i + 2] = Math.sin(angle) * radius;
      posArray[i + 3] = Math.random();
    }
    
    const positionFragmentShader = `
uniform sampler2D textureDefaultPosition;
uniform float time;
uniform float speed;
uniform float dieSpeed;
uniform float curlSize;
uniform float turbineRotation;

${curlNoise}

void main() {
  vec2 uv = gl_FragCoord.xy / resolution.xy;
  vec4 positionInfo = texture2D(texturePosition, uv);
  vec3 position = positionInfo.xyz;
  float life = positionInfo.a - dieSpeed;
  
  if (life < 0.0) {
    vec4 defaultPos = texture2D(textureDefaultPosition, uv);
    float spawnAngle = defaultPos.w * 6.28318 + turbineRotation * 3.0;
    float radius = 2.6 + defaultPos.x * 0.6;
    float stageX = -1.2 + defaultPos.y * 2.4;
    position.x = stageX;
    position.y = cos(spawnAngle) * radius;
    position.z = sin(spawnAngle) * radius;
    life = 0.5 + fract(defaultPos.z * 21.4131 + time * 0.12);
  } else {
    vec3 curlForce = curl(position * curlSize * 2.0, time * 0.4, 0.35);
    vec3 windForce = vec3(0.08 * speed, 0.0, 0.0);
    float radialDist = length(vec2(position.y, position.z));
    if (radialDist > 0.1) {
      vec2 radialDir = normalize(vec2(position.y, position.z));
      float swirlStrength = 0.08 * speed * (1.0 - smoothstep(2.5, 6.0, radialDist));
      windForce.y += -radialDir.y * swirlStrength;
      windForce.z += radialDir.x * swirlStrength;
      float expandRate = 0.012 * speed * smoothstep(0.0, 3.0, position.x);
      windForce.y += radialDir.x * expandRate;
      windForce.z += radialDir.y * expandRate;
    }
    position += windForce;
    position += curlForce * speed * 0.15;
    if (position.x > 12.0) {
      life -= dieSpeed * 2.0;
    }
  }
  
  gl_FragColor = vec4(position, life);
}
`;
    
    const positionVariable = gpuCompute.addVariable('texturePosition', positionFragmentShader, dtPosition);
    gpuCompute.setVariableDependencies(positionVariable, [positionVariable]);
    
    positionVariable.material.uniforms.textureDefaultPosition = { value: dtDefaultPosition };
    positionVariable.material.uniforms.time = { value: 0 };
    positionVariable.material.uniforms.speed = { value: 1.0 };
    positionVariable.material.uniforms.dieSpeed = { value: 0.008 };
    positionVariable.material.uniforms.curlSize = { value: 0.15 };
    positionVariable.material.uniforms.turbineRotation = { value: 0 };
    
    gpuCompute.init();
    
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * PARTICLE_COUNT * 3);
    
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      for (let j = 0; j < PARTICLE_COUNT; j++) {
        const idx = (i * PARTICLE_COUNT + j) * 3;
        positions[idx] = j / PARTICLE_COUNT;
        positions[idx + 1] = i / PARTICLE_COUNT;
        positions[idx + 2] = 0;
      }
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const particleVertexShader = `
      uniform sampler2D texturePosition;
      varying float vLife;
      varying vec3 vPosition;
      
      void main() {
        vec4 positionInfo = texture2D(texturePosition, position.xy);
        vec4 worldPosition = modelMatrix * vec4(positionInfo.xyz, 1.0);
        vec4 mvPosition = viewMatrix * worldPosition;
        
        vLife = positionInfo.w;
        vPosition = positionInfo.xyz;
        
        float size = smoothstep(0.0, 0.2, positionInfo.w) * smoothstep(1.0, 0.5, positionInfo.w);
        gl_PointSize = 80.0 / length(mvPosition.xyz) * size;
        
        gl_Position = projectionMatrix * mvPosition;
      }
    `;
    
    const particleFragmentShader = `
      varying float vLife;
      varying vec3 vPosition;
      
      uniform vec3 color1;
      uniform vec3 color2;
      uniform vec3 color3;
      
      void main() {
        vec2 center = gl_PointCoord - vec2(0.5);
        float dist = length(center);
        if (dist > 0.5) discard;
        
        float alpha = smoothstep(0.5, 0.1, dist) * smoothstep(0.0, 0.15, vLife) * smoothstep(1.0, 0.6, vLife);
        
        float t = smoothstep(1.5, 8.0, vPosition.x);
        vec3 color = mix(color1, color2, t * 0.7);
        color = mix(color, color3, t);
        
        gl_FragColor = vec4(color, alpha * 0.5);
      }
    `;
    
    const material = new THREE.ShaderMaterial({
      uniforms: {
        texturePosition: { value: null },
        color1: { value: new THREE.Color(0x3377aa) },
        color2: { value: new THREE.Color(0x2a6688) },
        color3: { value: new THREE.Color(0x1f4466) },
      },
      vertexShader: particleVertexShader,
      fragmentShader: particleFragmentShader,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    });
    
    const particles = new THREE.Points(geometry, material);
    scene.add(particles);
    
    let turbineRotation = 0;
    const clock = new THREE.Clock();
    
    let targetRotationY = 0;
    let targetRotationZ = 0;
    let currentRotationY = 0;
    let currentRotationZ = 0;
    const baseRotationY = Math.PI;
    let isMouseOverTurbine = false;
    
    document.addEventListener('mousemove', (event) => {
      const rect = container.getBoundingClientRect();
      const isOver = event.clientX >= rect.left && event.clientX <= rect.right &&
                     event.clientY >= rect.top && event.clientY <= rect.bottom;
      
      if (isOver) {
        isMouseOverTurbine = true;
        const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const mouseY = ((event.clientY - rect.top) / rect.height) * 2 - 1;
        targetRotationY = mouseX * 0.25;
        targetRotationZ = -mouseY * 0.15;
      } else if (isMouseOverTurbine) {
        isMouseOverTurbine = false;
        targetRotationY = 0;
        targetRotationZ = 0;
      }
    });
    
    function animate() {
      requestAnimationFrame(animate);
      
      const elapsed = clock.getElapsedTime();
      
      scene.traverse((obj) => {
        if (obj.userData && obj.userData.isRotatingStage) {
          if (obj.userData.stageIndex === 1) {
            obj.rotation.x -= 0.035;
          } else {
            obj.rotation.x += 0.035;
          }
        }
      });
      turbineRotation += 0.035;
      shaftGroup.rotation.x += 0.035;
      
      currentRotationY += (targetRotationY - currentRotationY) * 0.08;
      currentRotationZ += (targetRotationZ - currentRotationZ) * 0.08;
      scene.rotation.y = baseRotationY + currentRotationY;
      scene.rotation.z = currentRotationZ;
      
      positionVariable.material.uniforms.time.value = elapsed;
      positionVariable.material.uniforms.turbineRotation.value = turbineRotation;
      
      gpuCompute.compute();
      
      material.uniforms.texturePosition.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
      
      keyLight.intensity = 1.4 + Math.sin(elapsed * 1.5) * 0.1;
      
      controls.update();
      renderer.render(scene, camera);
    }
    
    animate();
    
    const resizeObserver = new ResizeObserver(() => {
      const newWidth = container.clientWidth;
      const newHeight = container.clientHeight;
      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(newWidth, newHeight);
      scene.position.x = newWidth < 400 ? 4 - 0.75 : 4;
    });
    resizeObserver.observe(container);
  }
  
  document.addEventListener('DOMContentLoaded', () => {
    init3DTurbine();
  });
  
  document.addEventListener('astro:page-load', () => {
    init3DTurbine();
  });
</script>

