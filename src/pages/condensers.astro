---
import type { Lang } from '@/i18n';
import { getBaseUrl } from '@/i18n';
import BaseLayout from '@/layouts/BaseLayout.astro';
import Breadcrumbs from '@/components/Breadcrumbs.astro';
import Faq from '@/components/Faq.astro';
import Partners from '@/components/Partners.astro';

const lang: Lang = 'ru';
const base = getBaseUrl(lang);

const faqItems = [
  {
    question: "Какой срок службы конденсаторов производства ООО «РУСТРЕЙД»?",
    answer: "Расчетный срок службы конденсаторов составляет не менее 40 лет при соблюдении правил эксплуатации и регулярном техническом обслуживании. Гарантийный срок составляет 24 месяца с момента ввода в эксплуатацию."
  },
  {
    question: "Возможна ли замена конденсатора без изменения фундаментов и подводящих трубопроводов?",
    answer: "Да, наши специалисты адаптируют конструкцию конденсатора под существующие присоединительные размеры и расположение опор. При необходимости выполняется обследование объекта для точного определения всех параметров и особенностей монтажа."
  },
  {
    question: "Какие материалы используются для изготовления трубок конденсатора при работе с морской водой?",
    answer: "Для работы с морской водой мы используем трубки из специальных сплавов с высокой коррозионной стойкостью, таких как MNK 70/30 (медно-никелевый сплав), нержавеющая сталь специальных марок или титановые сплавы. Выбор материала осуществляется в зависимости от конкретных условий эксплуатации и требований заказчика."
  },
  {
    question: "Какие сроки изготовления и поставки конденсаторов?",
    answer: "Сроки изготовления зависят от типоразмера и сложности конденсатора и составляют от 6 до 12 месяцев с момента согласования технического задания. Возможно ускорение производства при необходимости срочной замены оборудования."
  },
  {
    question: "Насколько точны расчеты онлайн-калькулятора?",
    answer: "Калькулятор даёт предварительную оценку с точностью ±15%. Результаты основаны на типовых параметрах конденсаторов серии КП/КГ. Для точного расчёта необходимо учитывать: давление пара на выхлопе турбины, температуру и качество охлаждающей воды, требуемый вакуум, режим работы станции. Наши инженеры выполнят детальный теплогидравлический расчёт бесплатно."
  },
  {
    question: "Почему расход воды для морской воды выше?",
    answer: "При использовании морской воды применяется коэффициент 1.15 к расчётному расходу. Это связано с: более низкой теплоёмкостью морской воды из-за солей, необходимостью снижения скорости потока для уменьшения коррозии трубок, учётом биообрастания и засорения. Также используются специальные коррозионностойкие материалы (медно-никелевые сплавы, титан), что влияет на конструкцию."
  },
  {
    question: "Как определяется модель конденсатора в калькуляторе?",
    answer: "Модель подбирается по мощности турбины: до 25 МВт — КП-2000, до 50 МВт — КП-3500, до 100 МВт — КГ-6200, до 200 МВт — КГ-10000, свыше 200 МВт — КГ-15000. Цифра в названии указывает на поверхность теплообмена в м². Окончательный выбор модели производится после детального расчёта с учётом всех параметров вашей турбоустановки."
  },
  {
    question: "Можно ли заказать конденсатор с параметрами, отличными от расчётных?",
    answer: "Да, мы проектируем конденсаторы под индивидуальные требования. Можно изменить: поверхность теплообмена, материал трубок и трубных досок, конструктивное исполнение (1/2/4-ходовой), поточность (1 или 2 потока). Калькулятор даёт отправную точку, финальные параметры согласовываются с нашими инженерами."
  }
];

const types = [
  {
    title: 'Конструктивное исполнение',
    description: 'Одно-, двух- или четырехходовое исполнение, адаптированное под конкретные требования заказчика и особенности турбины'
  },
  {
    title: 'Поточность',
    description: 'Одно- или двухпоточное исполнение для оптимальной организации движения рабочей среды и обеспечения максимальной эффективности теплообмена'
  },
  {
    title: 'Поверхность теплообмена',
    description: 'Диапазон поверхности теплообмена от 500 до 15 000 м², что позволяет подобрать оптимальное решение для турбин различной мощности'
  },
  {
    title: 'Тип охлаждающей воды',
    description: 'Специальные материалы и конструктивные решения для работы как с пресной, так и с морской водой с учетом особенностей конкретного объекта'
  }
];

const advantages = [
  {
    title: 'Двухпоточная конструкция',
    description: 'Позволяет проводить сервисное обслуживание и чистку трубного пучка одного потока без остановки оборудования, что значительно повышает экономические показатели',
    icon: '/img/Proektnaya_dokumentaciya/documents_files.svg'
  },
  {
    title: 'Пружинные опоры',
    description: 'Обеспечивают компенсацию температурных расширений без необходимости установки дополнительных компенсирующих устройств, что упрощает монтаж и эксплуатацию',
    icon: '/img/Proektnaya_dokumentaciya/protection_security_finger_thumb_biometr.svg'
  },
  {
    title: 'Специальные материалы',
    description: 'Применение материалов, устойчивых к различным рабочим средам, включая коррозионностойкие сплавы для работы с морской водой и агрессивными средами',
    icon: '/img/Proektnaya_dokumentaciya/magnifier_search.svg'
  }
];

const deliveryFeatures = [
  {
    title: 'Максимальная заводская готовность',
    description: 'Конденсаторы поставляются с максимальной степенью заводской готовности, что существенно сокращает сроки монтажа на объекте и ускоряет ввод в эксплуатацию.',
    tags: ['Готовые модули', 'Минимум монтажа', 'Быстрый запуск'],
    image: '/img/condensers/Maximum factory readiness.jpg'
  },
  {
    title: 'Комплектация эжекторами',
    description: 'Возможность комплектации пусковым и основным двуступенчатым пароструйным эжектором для создания и поддержания необходимого вакуума в конденсаторе.',
    tags: ['Пусковой эжектор', 'Основной эжектор', 'Высокий вакуум'],
    image: '/img/condensers/Complete with ejectors.jpg'
  },
  {
    title: 'Сокращение сроков монтажа',
    description: 'Продуманные конструктивные решения и высокая степень заводской готовности обеспечивают существенное сокращение сроков монтажа и ввода в эксплуатацию.',
    tags: ['Быстрый монтаж', 'Минимум подгонки', 'Экономия времени'],
    image: '/img/condensers/Reduction of installation time.jpg'
  }
];

const stats = [
  { value: 8, label: 'Выполненных проектов' },
  { value: 10, label: 'Постоянных клиентов' },
  { value: 5, label: 'Лет опыта' },
  { value: 20, label: 'Ведущих специалистов' }
];

const workAdvantages = [
  {
    title: 'Высокое качество',
    description: 'Используем передовые технологии и материалы, обеспечивающие долговечность и надежность оборудования',
    icon: '/img/lopatki/icons/like_6016641.png'
  },
  {
    title: 'Современное оборудование',
    description: 'Производство оснащено высокоточным оборудованием ведущих мировых производителей',
    icon: '/img/lopatki/icons/industrial-robot_9837143.png'
  },
  {
    title: 'Соответствие стандартам',
    description: 'Вся продукция соответствует требованиям ГОСТ, ISO и международным стандартам качества',
    icon: '/img/lopatki/icons/eac_17379530.png'
  },
  {
    title: 'Соблюдение сроков',
    description: 'Строгое соблюдение согласованных сроков изготовления и поставки продукции',
    icon: '/img/lopatki/icons/long-term_9966603.png'
  }
];
---

<BaseLayout 
  lang={lang} 
  title="Конденсаторы паровых турбин | РУСТРЕЙД"
  description="Высокоэффективные поверхностные конденсаторы различного исполнения для паровых турбин. Индивидуальное проектирование и изготовление."
  keywords="конденсаторы, паровые турбины, теплообменники, энергетическое оборудование, РУСТРЕЙД"
>
  <Breadcrumbs items={[{ label: 'Конденсаторы' }]} />

  <!-- Hero Section -->
  <section class="hero">
    <div class="hero-content">
      <h1>Конденсаторы паровых турбин</h1>
      <p>Высокоэффективные поверхностные конденсаторы различного исполнения для паровых турбин с оптимальными техническими характеристиками</p>
      <div class="hero-buttons">
        <button class="btn btn-accent" data-modal="condenser">
          <span>Заказать конденсатор</span>
          <img src="/img/arrow_right.svg" alt="" width="16" height="16" />
        </button>
      </div>
    </div>
  </section>

  <!-- About Section -->
  <section class="section about-turbines">
    <div class="section-header">
      <h2>О конденсаторах паровых турбин</h2>
    </div>
    <div class="about-content">
      <div class="about-text">
        <p>
          Конденсатор паровой турбины является ключевым элементом тепловых электростанций, предназначенным для конденсации отработавшего в турбине пара и создания вакуума, повышающего эффективность всей энергетической установки. От качества и надежности конденсатора напрямую зависят экономичность и стабильность работы всей электростанции.
        </p>
        <p>
          ООО «РУСТРЕЙД» предлагает поверхностные конденсаторы различного исполнения, обладающие следующими ключевыми преимуществами:
        </p>
        <ul class="features-list">
          <li><strong>Оптимальная конструкция</strong> – конденсаторы с одно-, двух- или четырехходовым исполнением, адаптированные под конкретные условия эксплуатации</li>
          <li><strong>Высокая эффективность</strong> – максимальная теплопередача при минимальном гидравлическом сопротивлении</li>
          <li><strong>Надежность</strong> – использование высококачественных материалов, устойчивых к различным рабочим средам, включая морскую воду</li>
          <li><strong>Удобство обслуживания</strong> – специальные конструкторские решения, позволяющие проводить сервисное обслуживание без полного останова оборудования</li>
        </ul>
        <p>
          Наши конденсаторы изготавливаются по индивидуальному техническому заданию заказчика, что позволяет оптимально интегрировать их в существующие или проектируемые энергетические системы с максимальной эффективностью.
        </p>
      </div>
      <div class="about-image">
        <img src="/img/condensers/condenser_main.webp" alt="Конденсатор паровой турбины" />
      </div>
    </div>
  </section>

  <!-- Types Section -->
  <section class="section modifications">
    <div class="section-header">
      <h2>Виды и модификации конденсаторов</h2>
      <p>Разнообразие конструктивных исполнений для оптимального соответствия техническим требованиям различных энергетических установок</p>
    </div>
    <div class="modifications-grid">
      {types.map((type) => (
        <div class="modification-card">
          <div class="modification-header">
            <h3>{type.title}</h3>
          </div>
          <p class="modification-description">{type.description}</p>
        </div>
      ))}
    </div>
  </section>

  <!-- Technical Features Section with 3D Turbine -->
  <section class="section tech-features-infographic">
    <div class="turbine-3d-container" id="turbine-canvas"></div>
    
    <div class="tech-features-content">
      <div class="section-header">
        <h2>Технические характеристики</h2>
        <p>Профессиональное оборудование, разработанное с учетом всех требований энергетической отрасли</p>
      </div>
      
      <div class="tech-features-cards">
        <div class="infographic-card">
          <div class="card-icon">
            <svg viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M24 4L4 14V34L24 44L44 34V14L24 4Z" stroke="currentColor" stroke-width="2"/>
              <path d="M24 18L14 23V33L24 38L34 33V23L24 18Z" fill="currentColor" opacity="0.2"/>
              <path d="M24 4V18M4 14L24 24M44 14L24 24" stroke="currentColor" stroke-width="2"/>
              <circle cx="24" cy="24" r="6" stroke="currentColor" stroke-width="2"/>
              <path d="M21 24L23 26L27 22" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
          <h3>Высокая эффективность теплообмена</h3>
          <p>Оптимизированные поверхности теплообмена от 500 до 15 000 м² обеспечивают максимальную конденсацию пара</p>
        </div>
        
        <div class="infographic-card">
          <div class="card-icon">
            <svg viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
              <circle cx="24" cy="24" r="18" stroke="currentColor" stroke-width="2"/>
              <path d="M24 12V24L32 28" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              <path d="M38 24C38 31.732 31.732 38 24 38" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
              <circle cx="24" cy="24" r="4" fill="currentColor" opacity="0.3"/>
            </svg>
          </div>
          <h3>Долгий срок службы</h3>
          <p>Расчётный ресурс конденсаторов составляет не менее 40 лет при соблюдении правил эксплуатации</p>
        </div>
        
        <div class="infographic-card">
          <div class="card-icon">
            <svg viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M24 4L6 12V24C6 35 24 44 24 44C24 44 42 35 42 24V12L24 4Z" stroke="currentColor" stroke-width="2"/>
              <path d="M24 10L12 16V24C12 31 24 38 24 38C24 38 36 31 36 24V16L24 10Z" fill="currentColor" opacity="0.15"/>
              <path d="M17 24L22 29L31 20" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
          <h3>Коррозионная стойкость</h3>
          <p>Специальные материалы для работы с морской и пресной водой, включая медно-никелевые и титановые сплавы</p>
        </div>
        
        <div class="infographic-card">
          <div class="card-icon">
            <svg viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M12 8c-3.3 0-6 2.7-6 6s2.7 6 6 6c1.1 0 2.1-.3 3-.8L28 32.2c-.5.9-.8 1.9-.8 3 0 3.3 2.7 6 6 6s6-2.7 6-6-2.7-6-6-6c-1.1 0-2.1.3-3 .8L17.2 17c.5-.9.8-1.9.8-3 0-3.3-2.7-6-6-6z" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" fill="currentColor" fill-opacity="0.15"/>
              <circle cx="12" cy="14" r="2.5" fill="currentColor"/>
              <circle cx="33.2" cy="35.2" r="2.5" fill="currentColor"/>
            </svg>
          </div>
          <h3>Минимальное гидравлическое сопротивление</h3>
          <p>Оптимизированные каналы для охлаждающей воды обеспечивают экономию электроэнергии на прокачку</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Calculator Section -->
  <section class="section calculator-section">
    <div class="calculator-wrapper">
      <div class="calculator-header">
        <div class="calculator-title">
          <h2>Калькулятор подбора</h2>
          <p>Предварительный расчет оптимальной модели конденсатора</p>
        </div>
      </div>
      
      <div class="calculator-body">
        <div class="calculator-left">
          <h4 class="calc-section-title">Параметры для расчета</h4>
          <div class="calculator-form-card">
            <div class="form-icon-row">
              <div class="form-group-modern">
                <div class="input-wrapper">
                  <label for="turbine-power">Мощность турбины</label>
                  <div class="input-with-unit">
                    <input type="number" id="turbine-power" name="turbine-power" min="1" max="500" placeholder="0" />
                    <span class="unit">МВт</span>
                  </div>
                </div>
              </div>
              
              <div class="form-group-modern">
                <div class="input-wrapper">
                  <label for="water-type">Тип воды</label>
                  <select id="water-type" name="water-type">
                    <option value="fresh">Пресная</option>
                    <option value="sea">Морская</option>
                  </select>
                </div>
              </div>
            </div>
            
            <button type="button" id="calculate-btn" class="calculate-btn-modern">
              <span class="btn-text">Рассчитать</span>
            </button>
          </div>
          
          <div class="calculator-results-card" id="calculation-results">
            <div class="results-header">
              <h4>Рекомендуемый конденсатор</h4>
            </div>
            
            <div class="results-grid">
              <div class="result-card">
                <span class="result-card-label">Модель</span>
                <span class="result-card-value" id="model-result">—</span>
              </div>
              
              <div class="result-card">
                <span class="result-card-label">Поверхность</span>
                <span class="result-card-value" id="surface-result">—</span>
              </div>
              
              <div class="result-card">
                <span class="result-card-label">Тип исполнения</span>
                <span class="result-card-value" id="type-result">—</span>
              </div>
              
              <div class="result-card">
                <span class="result-card-label">Вакуум</span>
                <span class="result-card-value" id="vacuum-result">—</span>
              </div>
            </div>
          </div>
        </div>
        
        <div class="calculator-right">
          <div class="description-content">
            <h4>Что рассчитывает калькулятор?</h4>
            <ul class="calc-features">
              <li><strong>Модель конденсатора</strong> — оптимальный типоразмер из серии КП/КГ для вашей турбины</li>
              <li><strong>Поверхность теплообмена</strong> — расчетная площадь в м² для эффективной конденсации пара</li>
              <li><strong>Расход воды</strong> — необходимый объем охлаждающей воды в м³/ч</li>
              <li><strong>Масса конденсатора</strong> — приблизительный вес оборудования для проектирования фундамента</li>
            </ul>
          </div>
          <div class="description-note">
            <h4>Как пользоваться</h4>
            <p>Введите мощность турбины (МВт) и выберите тип охлаждающей воды. Калькулятор автоматически подберет оптимальную модель конденсатора с учетом коэффициента для морской воды.</p>
          </div>
        </div>
      </div>
      
      <p class="calculator-note">
        Результаты предварительные. Для точного расчета обратитесь к специалистам.
      </p>
    </div>
  </section>

  <!-- Technical Advantages Section -->
  <section class="section services">
    <div class="section-header">
      <h2>Технические преимущества</h2>
      <p>Инновационные конструкторские решения, обеспечивающие высокую эффективность и надежность конденсаторов</p>
    </div>
    <div class="additional-services-grid">
      {advantages.map((advantage) => (
        <div class="additional-service-card">
          <div class="additional-service-header">
            <div class="additional-service-icon">
              <img src={advantage.icon} alt={advantage.title} />
            </div>
            <h3>{advantage.title}</h3>
          </div>
          <p>{advantage.description}</p>
        </div>
      ))}
    </div>
  </section>

  <!-- Delivery Section -->
  <section class="section delivery-section">
    <div class="section-header">
      <h2>Комплектация и поставка</h2>
      <p>Максимальная заводская готовность для быстрого монтажа и ввода в эксплуатацию</p>
    </div>
    <div class="delivery-grid">
      {deliveryFeatures.map((feature) => (
        <div class="delivery-card">
          <img src={feature.image} alt={feature.title} class="delivery-bg-image" />
          <div class="delivery-content">
            <div class="delivery-title-wrapper">
              <h3>{feature.title}</h3>
            </div>
            <div class="delivery-description">
              <p>{feature.description}</p>
            </div>
            <div class="delivery-tags">
              {feature.tags.map((tag) => (
                <span class="tag">{tag}</span>
              ))}
            </div>
          </div>
        </div>
      ))}
    </div>
  </section>

  <!-- Stats Section -->
  <section class="section stats-section">
    <div class="stats-grid">
      {stats.map((stat) => (
        <div class="stat-card">
          <div class="stat-value" data-value={stat.value}>0</div>
          <div class="stat-label">{stat.label}</div>
        </div>
      ))}
    </div>
  </section>

  <!-- Work Advantages Section -->
  <section class="section work-advantages-section">
    <div class="section-header">
      <h2>Преимущества работы с нами</h2>
      <p>Профессиональная команда инженеров и технологов с богатым опытом в производстве энергетического оборудования</p>
    </div>
    <div class="work-advantages-grid">
      {workAdvantages.map((advantage) => (
        <div class="work-advantage-card">
          <div class="work-advantage-icon">
            <img src={advantage.icon} alt="" width="48" height="48" />
          </div>
          <h3>{advantage.title}</h3>
          <p>{advantage.description}</p>
        </div>
      ))}
    </div>
  </section>

  <!-- Partners Section -->
  <Partners />

  <!-- CTA Section -->
  <section class="section cta-section">
    <div class="cta-content">
      <h2>Готовы к заказу? Обсудите проект с экспертом</h2>
      <p>Наши специалисты помогут подобрать оптимальное решение для вашего проекта и ответят на все вопросы</p>
      <button class="btn btn-accent" data-modal="consultation">
        <span>Получить консультацию</span>
        <img src="/img/arrow_right.svg" alt="" width="16" height="16" />
      </button>
    </div>
  </section>

  <!-- FAQ Section -->
  <Faq items={faqItems} title="Ответы на вопросы" subtitle="Часто задаваемые вопросы о конденсаторах паровых турбин" />

</BaseLayout>

<script>
  function animateStats() {
    const statValues = document.querySelectorAll('.stat-value');
    
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const el = entry.target as HTMLElement;
          const target = parseInt(el.dataset.value || '0');
          let current = 0;
          const increment = target / 50;
          const timer = setInterval(() => {
            current += increment;
            if (current >= target) {
              current = target;
              clearInterval(timer);
            }
            el.textContent = String(Math.floor(current));
          }, 30);
          observer.unobserve(el);
        }
      });
    }, { threshold: 0.5 });

    statValues.forEach(stat => observer.observe(stat));
  }

  // Calculator logic
  function initCalculator() {
    const calculateBtn = document.getElementById('calculate-btn');
    const resultsDiv = document.getElementById('calculation-results');
    
    if (calculateBtn) {
      calculateBtn.addEventListener('click', function() {
        const powerInput = document.getElementById('turbine-power') as HTMLInputElement;
        const waterTypeSelect = document.getElementById('water-type') as HTMLSelectElement;
        
        const power = parseFloat(powerInput?.value || '0');
        const waterType = waterTypeSelect?.value || 'fresh';
        
        if (!power || power <= 0) {
          alert('Пожалуйста, введите мощность турбины');
          return;
        }
        
        // Calculate results based on power and water type
        let model = '';
        let surface = 0;
        let typeResult = '';
        let vacuum = '';
        
        if (power <= 6) {
          model = 'К-' + Math.round(power * 100);
          surface = Math.round(power * 150);
          typeResult = 'Одноходовой';
          vacuum = '94-96%';
        } else if (power <= 25) {
          model = 'К-' + Math.round(power * 80);
          surface = Math.round(power * 120);
          typeResult = 'Двухходовой';
          vacuum = '95-97%';
        } else if (power <= 60) {
          model = 'К-' + Math.round(power * 60);
          surface = Math.round(power * 100);
          typeResult = 'Двухходовой двухпоточный';
          vacuum = '96-97.5%';
        } else {
          model = 'К-' + Math.round(power * 50);
          surface = Math.round(power * 85);
          typeResult = 'Четырехходовой двухпоточный';
          vacuum = '96.5-98%';
        }
        
        // Adjust for sea water
        if (waterType === 'sea') {
          model += 'М';
          typeResult += ' (морское исполнение)';
        }
        
        // Update results
        const modelResult = document.getElementById('model-result');
        const surfaceResult = document.getElementById('surface-result');
        const typeResultEl = document.getElementById('type-result');
        const vacuumResult = document.getElementById('vacuum-result');
        
        if (modelResult) modelResult.textContent = model;
        if (surfaceResult) surfaceResult.textContent = surface + ' м²';
        if (typeResultEl) typeResultEl.textContent = typeResult;
        if (vacuumResult) vacuumResult.textContent = vacuum;
        
        if (resultsDiv) {
          resultsDiv.classList.add('active');
        }
      });
    }
  }

  // 3D Realistic Steel Turbine
  async function init3DTurbine() {
    const container = document.getElementById('turbine-canvas');
    if (!container) return;
    
    const THREE = await import('https://unpkg.com/three@0.153.0/build/three.module.js');
    const { OrbitControls } = await import('https://unpkg.com/three@0.153.0/examples/jsm/controls/OrbitControls.js');
    const { GPUComputationRenderer } = await import('https://unpkg.com/three@0.153.0/examples/jsm/misc/GPUComputationRenderer.js');
    
    const scene = new THREE.Scene();
    scene.background = null;
    
    const width = container.clientWidth;
    const height = container.clientHeight;
    
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    renderer.setClearColor(0x000000, 0);
    container.appendChild(renderer.domElement);
    
    const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
    camera.position.set(0, 3, 14);
    camera.lookAt(0, 0, 0);
    
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0, 0);
    controls.enableZoom = false;
    controls.enablePan = false;
    
    const isMobile = width < 400;
    scene.position.x = isMobile ? 4 - 0.75 : 4;
    scene.rotation.y = Math.PI;
    scene.scale.setScalar(1.5);
    
    const steelMaterials = {
      polishedSteel: new THREE.MeshStandardMaterial({ color: 0xB0B0B0, metalness: 0.6, roughness: 0.25 }),
      brushedSteel: new THREE.MeshStandardMaterial({ color: 0x909090, metalness: 0.5, roughness: 0.4 }),
      darkSteel: new THREE.MeshStandardMaterial({ color: 0x606060, metalness: 0.4, roughness: 0.5 }),
      bladeSteel: new THREE.MeshStandardMaterial({ color: 0xA8A8A8, metalness: 0.55, roughness: 0.3 }),
      chromeSteel: new THREE.MeshStandardMaterial({ color: 0xC8C8C8, metalness: 0.7, roughness: 0.15 })
    };
    
    const ambient = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambient);
    
    const keyLight = new THREE.DirectionalLight(0xffffff, 2.0);
    keyLight.position.set(8, 12, 10);
    keyLight.castShadow = true;
    scene.add(keyLight);
    
    const fillLight = new THREE.DirectionalLight(0xaabbcc, 1.0);
    fillLight.position.set(-8, 4, -6);
    scene.add(fillLight);
    
    const rimLight = new THREE.DirectionalLight(0xccddff, 1.2);
    rimLight.position.set(-3, -3, 8);
    scene.add(rimLight);
    
    function createTurbineStage(params) {
      const group = new THREE.Group();
      group.position.x = params.xOffset;
      
      const discGeometry = new THREE.CylinderGeometry(params.radius, params.radius * 0.95, params.thickness, 128);
      discGeometry.rotateZ(Math.PI / 2);
      const discMesh = new THREE.Mesh(discGeometry, steelMaterials.brushedSteel.clone());
      discMesh.castShadow = true;
      group.add(discMesh);
      
      const hubRingGeo = new THREE.TorusGeometry(params.radius * 0.4, 0.05, 16, 64);
      hubRingGeo.rotateY(Math.PI / 2);
      const hubRingMesh = new THREE.Mesh(hubRingGeo, steelMaterials.chromeSteel);
      hubRingMesh.position.x = params.thickness / 2 + 0.02;
      group.add(hubRingMesh);
      
      for (let i = 0; i < params.bladeCount; i++) {
        const angle = (2 * Math.PI * i) / params.bladeCount;
        const bladeGeo = new THREE.BoxGeometry(params.bladeThickness, params.bladeLength, params.bladeWidth);
        const bladeMat = (i % 3 === 0) ? steelMaterials.bladeSteel.clone() : steelMaterials.polishedSteel.clone();
        const bladeMesh = new THREE.Mesh(bladeGeo, bladeMat);
        bladeMesh.castShadow = true;
        
        const radial = new THREE.Vector3(0, Math.cos(angle), Math.sin(angle));
        const offset = params.radius + params.bladeLength / 2;
        bladeMesh.position.copy(radial.clone().multiplyScalar(offset));
        
        const quaternion = new THREE.Quaternion();
        quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), radial);
        bladeMesh.quaternion.copy(quaternion);
        
        group.add(bladeMesh);
      }
      
      return group;
    }
    
    const stages = [
      { radius: 2.2, thickness: 0.4, bladeCount: 52, bladeLength: 0.85, bladeWidth: 0.12, bladeThickness: 0.08, xOffset: -1.4 },
      { radius: 2.0, thickness: 0.38, bladeCount: 48, bladeLength: 0.75, bladeWidth: 0.11, bladeThickness: 0.07, xOffset: 0.0 },
      { radius: 1.8, thickness: 0.35, bladeCount: 44, bladeLength: 0.65, bladeWidth: 0.10, bladeThickness: 0.065, xOffset: 1.2 },
    ];
    
    const totalLength = stages[stages.length - 1].xOffset - stages[0].xOffset + 2.5;
    const shaftGroup = new THREE.Group();
    
    const shaftGeo = new THREE.CylinderGeometry(0.45, 0.45, totalLength, 64);
    shaftGeo.rotateZ(Math.PI / 2);
    const shaftMesh = new THREE.Mesh(shaftGeo, steelMaterials.polishedSteel);
    shaftMesh.castShadow = true;
    shaftMesh.position.x = (stages[0].xOffset + stages[stages.length - 1].xOffset) / 2;
    shaftGroup.add(shaftMesh);
    
    scene.add(shaftGroup);
    
    const stageGroups = [];
    stages.forEach((params, idx) => {
      const stageGroup = createTurbineStage(params);
      stageGroup.userData.isRotatingStage = true;
      stageGroup.userData.stageIndex = idx;
      scene.add(stageGroup);
      stageGroups.push(stageGroup);
    });
    
    const simplexNoiseDerivatives4 = `
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
float mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
float permute(float x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
float taylorInvSqrt(float r) { return 1.79284291400159 - 0.85373472095314 * r; }
vec4 grad4(float j, vec4 ip) {
  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
  vec4 p,s;
  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
  s = vec4(lessThan(p, vec4(0.0)));
  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;
  return p;
}
#define F4 0.309016994374947451
vec4 snoise4(vec4 v) {
  const vec4 C = vec4(0.138196601125011, 0.276393202250021, 0.414589803375032, -0.447213595499958);
  vec4 i = floor(v + dot(v, vec4(F4)));
  vec4 x0 = v - i + dot(i, C.xxxx);
  vec4 i0;
  vec3 isX = step(x0.yzw, x0.xxx);
  vec3 isYZ = step(x0.zww, x0.yyz);
  i0.x = isX.x + isX.y + isX.z;
  i0.yzw = 1.0 - isX;
  i0.y += isYZ.x + isYZ.y;
  i0.zw += 1.0 - isYZ.xy;
  i0.z += isYZ.z;
  i0.w += 1.0 - isYZ.z;
  vec4 i3 = clamp(i0, 0.0, 1.0);
  vec4 i2 = clamp(i0 - 1.0, 0.0, 1.0);
  vec4 i1 = clamp(i0 - 2.0, 0.0, 1.0);
  vec4 x1 = x0 - i1 + C.xxxx;
  vec4 x2 = x0 - i2 + C.yyyy;
  vec4 x3 = x0 - i3 + C.zzzz;
  vec4 x4 = x0 + C.wwww;
  i = mod289(i);
  float j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x);
  vec4 j1 = permute(permute(permute(permute(i.w + vec4(i1.w, i2.w, i3.w, 1.0)) + i.z + vec4(i1.z, i2.z, i3.z, 1.0)) + i.y + vec4(i1.y, i2.y, i3.y, 1.0)) + i.x + vec4(i1.x, i2.x, i3.x, 1.0));
  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0);
  vec4 p0 = grad4(j0, ip);
  vec4 p1 = grad4(j1.x, ip);
  vec4 p2 = grad4(j1.y, ip);
  vec4 p3 = grad4(j1.z, ip);
  vec4 p4 = grad4(j1.w, ip);
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
  p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
  p4 *= taylorInvSqrt(dot(p4,p4));
  vec3 values0 = vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2));
  vec2 values1 = vec2(dot(p3, x3), dot(p4, x4));
  vec3 m0 = max(0.5 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
  vec2 m1 = max(0.5 - vec2(dot(x3,x3), dot(x4,x4)), 0.0);
  vec3 temp0 = -6.0 * m0 * m0 * values0;
  vec2 temp1 = -6.0 * m1 * m1 * values1;
  vec3 mmm0 = m0 * m0 * m0;
  vec2 mmm1 = m1 * m1 * m1;
  float dx = temp0[0] * x0.x + temp0[1] * x1.x + temp0[2] * x2.x + temp1[0] * x3.x + temp1[1] * x4.x + mmm0[0] * p0.x + mmm0[1] * p1.x + mmm0[2] * p2.x + mmm1[0] * p3.x + mmm1[1] * p4.x;
  float dy = temp0[0] * x0.y + temp0[1] * x1.y + temp0[2] * x2.y + temp1[0] * x3.y + temp1[1] * x4.y + mmm0[0] * p0.y + mmm0[1] * p1.y + mmm0[2] * p2.y + mmm1[0] * p3.y + mmm1[1] * p4.y;
  float dz = temp0[0] * x0.z + temp0[1] * x1.z + temp0[2] * x2.z + temp1[0] * x3.z + temp1[1] * x4.z + mmm0[0] * p0.z + mmm0[1] * p1.z + mmm0[2] * p2.z + mmm1[0] * p3.z + mmm1[1] * p4.z;
  float dw = temp0[0] * x0.w + temp0[1] * x1.w + temp0[2] * x2.w + temp1[0] * x3.w + temp1[1] * x4.w + mmm0[0] * p0.w + mmm0[1] * p1.w + mmm0[2] * p2.w + mmm1[0] * p3.w + mmm1[1] * p4.w;
  return vec4(dx, dy, dz, dw) * 49.0;
}
`;

    const curlNoise = `
${simplexNoiseDerivatives4}
vec3 curl(vec3 p, float noiseTime, float persistence) {
  vec4 xNoisePotentialDerivatives = vec4(0.0);
  vec4 yNoisePotentialDerivatives = vec4(0.0);
  vec4 zNoisePotentialDerivatives = vec4(0.0);
  for (int i = 0; i < 3; ++i) {
    float twoPowI = pow(2.0, float(i));
    float scale = 0.5 * twoPowI * pow(persistence, float(i));
    xNoisePotentialDerivatives += snoise4(vec4(p * twoPowI, noiseTime)) * scale;
    yNoisePotentialDerivatives += snoise4(vec4((p + vec3(123.4, 129845.6, -1239.1)) * twoPowI, noiseTime)) * scale;
    zNoisePotentialDerivatives += snoise4(vec4((p + vec3(-9519.0, 9051.0, -123.0)) * twoPowI, noiseTime)) * scale;
  }
  return vec3(
    zNoisePotentialDerivatives[1] - yNoisePotentialDerivatives[2],
    xNoisePotentialDerivatives[2] - zNoisePotentialDerivatives[0],
    yNoisePotentialDerivatives[0] - xNoisePotentialDerivatives[1]
  );
}
`;

    const PARTICLE_COUNT = 90;
    const gpuCompute = new GPUComputationRenderer(PARTICLE_COUNT, PARTICLE_COUNT, renderer);
    
    const dtPosition = gpuCompute.createTexture();
    const dtDefaultPosition = gpuCompute.createTexture();
    const posArray = dtPosition.image.data;
    const defaultPosArray = dtDefaultPosition.image.data;
    
    for (let i = 0; i < posArray.length; i += 4) {
      defaultPosArray[i] = Math.random();
      defaultPosArray[i + 1] = Math.random();
      defaultPosArray[i + 2] = Math.random();
      defaultPosArray[i + 3] = Math.random();
      
      const angle = defaultPosArray[i + 3] * Math.PI * 2;
      const radius = 2.5 + defaultPosArray[i] * 0.8;
      const axial = defaultPosArray[i + 1] * 2.3 - 1.15;
      
      posArray[i] = axial;
      posArray[i + 1] = Math.cos(angle) * radius;
      posArray[i + 2] = Math.sin(angle) * radius;
      posArray[i + 3] = Math.random();
    }
    
    const positionFragmentShader = `
uniform sampler2D textureDefaultPosition;
uniform float time;
uniform float speed;
uniform float dieSpeed;
uniform float curlSize;
uniform float turbineRotation;

${curlNoise}

void main() {
  vec2 uv = gl_FragCoord.xy / resolution.xy;
  vec4 positionInfo = texture2D(texturePosition, uv);
  vec3 position = positionInfo.xyz;
  float life = positionInfo.a - dieSpeed;
  
  if (life < 0.0) {
    vec4 defaultPos = texture2D(textureDefaultPosition, uv);
    float spawnAngle = defaultPos.w * 6.28318 + turbineRotation * 3.0;
    float radius = 2.6 + defaultPos.x * 0.6;
    float stageX = -1.2 + defaultPos.y * 2.4;
    position.x = stageX;
    position.y = cos(spawnAngle) * radius;
    position.z = sin(spawnAngle) * radius;
    life = 0.5 + fract(defaultPos.z * 21.4131 + time * 0.12);
  } else {
    vec3 curlForce = curl(position * curlSize * 2.0, time * 0.4, 0.35);
    vec3 windForce = vec3(0.08 * speed, 0.0, 0.0);
    
    float radialDist = length(vec2(position.y, position.z));
    if (radialDist > 0.1) {
      vec2 radialDir = normalize(vec2(position.y, position.z));
      float swirlStrength = 0.08 * speed * (1.0 - smoothstep(2.5, 6.0, radialDist));
      windForce.y += -radialDir.y * swirlStrength;
      windForce.z += radialDir.x * swirlStrength;
      
      float expandRate = 0.012 * speed * smoothstep(0.0, 3.0, position.x);
      windForce.y += radialDir.x * expandRate;
      windForce.z += radialDir.y * expandRate;
    }
    
    position += windForce;
    position += curlForce * speed * 0.15;
    
    if (position.x > 12.0) {
      life -= dieSpeed * 2.0;
    }
  }
  
  gl_FragColor = vec4(position, life);
}
`;
    
    const positionVariable = gpuCompute.addVariable('texturePosition', positionFragmentShader, dtPosition);
    gpuCompute.setVariableDependencies(positionVariable, [positionVariable]);
    
    positionVariable.material.uniforms.textureDefaultPosition = { value: dtDefaultPosition };
    positionVariable.material.uniforms.time = { value: 0 };
    positionVariable.material.uniforms.speed = { value: 1.0 };
    positionVariable.material.uniforms.dieSpeed = { value: 0.008 };
    positionVariable.material.uniforms.curlSize = { value: 0.15 };
    positionVariable.material.uniforms.turbineRotation = { value: 0 };
    
    gpuCompute.init();
    
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * PARTICLE_COUNT * 3);
    
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      for (let j = 0; j < PARTICLE_COUNT; j++) {
        const idx = (i * PARTICLE_COUNT + j) * 3;
        positions[idx] = j / PARTICLE_COUNT;
        positions[idx + 1] = i / PARTICLE_COUNT;
        positions[idx + 2] = 0;
      }
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const particleVertexShader = `
      uniform sampler2D texturePosition;
      varying float vLife;
      varying vec3 vPosition;
      
      void main() {
        vec4 positionInfo = texture2D(texturePosition, position.xy);
        vec4 worldPosition = modelMatrix * vec4(positionInfo.xyz, 1.0);
        vec4 mvPosition = viewMatrix * worldPosition;
        
        vLife = positionInfo.w;
        vPosition = positionInfo.xyz;
        
        float size = smoothstep(0.0, 0.2, positionInfo.w) * smoothstep(1.0, 0.5, positionInfo.w);
        gl_PointSize = 80.0 / length(mvPosition.xyz) * size;
        
        gl_Position = projectionMatrix * mvPosition;
      }
    `;
    
    const particleFragmentShader = `
      varying float vLife;
      varying vec3 vPosition;
      
      uniform vec3 color1;
      uniform vec3 color2;
      uniform vec3 color3;
      
      void main() {
        vec2 center = gl_PointCoord - vec2(0.5);
        float dist = length(center);
        if (dist > 0.5) discard;
        
        float alpha = smoothstep(0.5, 0.1, dist) * smoothstep(0.0, 0.15, vLife) * smoothstep(1.0, 0.6, vLife);
        
        float t = smoothstep(1.5, 8.0, vPosition.x);
        vec3 color = mix(color1, color2, t * 0.7);
        color = mix(color, color3, t);
        
        gl_FragColor = vec4(color, alpha * 0.5);
      }
    `;
    
    const material = new THREE.ShaderMaterial({
      uniforms: {
        texturePosition: { value: null },
        color1: { value: new THREE.Color(0x3377aa) },
        color2: { value: new THREE.Color(0x2a6688) },
        color3: { value: new THREE.Color(0x1f4466) },
      },
      vertexShader: particleVertexShader,
      fragmentShader: particleFragmentShader,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
    });
    
    const particles = new THREE.Points(geometry, material);
    scene.add(particles);
    
    let turbineRotation = 0;
    const clock = new THREE.Clock();
    
    let targetRotationY = 0;
    let targetRotationZ = 0;
    let currentRotationY = 0;
    let currentRotationZ = 0;
    const baseRotationY = Math.PI;
    let isMouseOverTurbine = false;
    
    document.addEventListener('mousemove', (event) => {
      const rect = container.getBoundingClientRect();
      const isOver = event.clientX >= rect.left && event.clientX <= rect.right &&
                     event.clientY >= rect.top && event.clientY <= rect.bottom;
      
      if (isOver) {
        isMouseOverTurbine = true;
        const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const mouseY = ((event.clientY - rect.top) / rect.height) * 2 - 1;
        targetRotationY = mouseX * 0.25;
        targetRotationZ = -mouseY * 0.15;
      } else if (isMouseOverTurbine) {
        isMouseOverTurbine = false;
        targetRotationY = 0;
        targetRotationZ = 0;
      }
    });
    
    function animate() {
      requestAnimationFrame(animate);
      
      const elapsed = clock.getElapsedTime();
      
      scene.traverse((obj) => {
        if (obj.userData && obj.userData.isRotatingStage) {
          if (obj.userData.stageIndex === 1) {
            obj.rotation.x -= 0.035;
          } else {
            obj.rotation.x += 0.035;
          }
        }
      });
      turbineRotation += 0.035;
      shaftGroup.rotation.x += 0.035;
      
      currentRotationY += (targetRotationY - currentRotationY) * 0.08;
      currentRotationZ += (targetRotationZ - currentRotationZ) * 0.08;
      scene.rotation.y = baseRotationY + currentRotationY;
      scene.rotation.z = currentRotationZ;
      
      positionVariable.material.uniforms.time.value = elapsed;
      positionVariable.material.uniforms.turbineRotation.value = turbineRotation;
      
      gpuCompute.compute();
      
      material.uniforms.texturePosition.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
      
      keyLight.intensity = 1.4 + Math.sin(elapsed * 1.5) * 0.1;
      
      controls.update();
      renderer.render(scene, camera);
    }
    
    animate();
    
    const resizeObserver = new ResizeObserver(() => {
      const newWidth = container.clientWidth;
      const newHeight = container.clientHeight;
      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(newWidth, newHeight);
      scene.position.x = newWidth < 400 ? 4 - 0.75 : 4;
    });
    resizeObserver.observe(container);
  }

  document.addEventListener('astro:page-load', () => {
    animateStats();
    initCalculator();
    init3DTurbine();
  });
  document.addEventListener('DOMContentLoaded', () => {
    animateStats();
    initCalculator();
    init3DTurbine();
  });
</script>

<style>
  /* Hero Section */
  .hero {
    background: linear-gradient(59deg, rgba(42, 45, 46, 0.70) 0%, rgba(0, 0, 0, 0.40) 31.59%, rgba(42, 45, 46, 0.70) 100%), 
                url('/img/condensers/majer.webp') center/cover no-repeat;
    border-radius: var(--radius-xl);
    padding: var(--space-16) var(--space-8);
    margin-bottom: var(--space-12);
    min-height: 400px;
    display: flex;
    align-items: center;
  }

  .hero-content {
    max-width: 700px;
    color: var(--color-white);
  }

  .hero h1 {
    font-size: clamp(32px, 5vw, 48px);
    color: var(--color-white);
    margin-bottom: var(--space-4);
    letter-spacing: -1px;
    line-height: 1.2;
  }

  .hero p {
    font-size: var(--text-lg);
    opacity: 0.9;
    line-height: 1.6;
    max-width: 600px;
    margin-bottom: var(--space-6);
  }

  .hero-buttons {
    display: flex;
    gap: var(--space-4);
    flex-wrap: wrap;
  }

  /* Section Common Styles */
  .section {
    margin-bottom: var(--space-16);
  }

  .section-header {
    margin-bottom: var(--space-8);
  }

  .section-header h2 {
    font-size: var(--text-3xl);
    color: var(--color-primary);
    margin-bottom: var(--space-3);
  }

  .section-header p {
    font-size: var(--text-lg);
    color: var(--color-text-muted);
    max-width: 700px;
  }

  /* About Section - Like Turbines Page */
  .about-turbines .about-content {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-8);
    align-items: start;
  }

  .about-text {
    display: flex;
    flex-direction: column;
    gap: var(--space-4);
  }

  .about-text p {
    font-size: var(--text-base);
    line-height: 1.7;
    color: var(--color-text-muted);
  }

  .about-text strong {
    color: var(--color-primary);
  }

  .about-image {
    border-radius: var(--radius-xl);
    overflow: hidden;
    height: 100%;
    min-height: 400px;
  }

  .about-image img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.5s ease;
  }

  .about-image:hover img {
    transform: scale(1.03);
  }

  .features-list {
    list-style: none;
    padding: 0;
    display: flex;
    flex-direction: column;
    gap: var(--space-3);
  }

  .features-list li {
    padding-left: var(--space-6);
    position: relative;
    color: var(--color-text-muted);
    line-height: 1.6;
  }

  .features-list li::before {
    content: '';
    position: absolute;
    left: 0;
    top: 8px;
    width: 8px;
    height: 8px;
    background: var(--color-accent);
    border-radius: 50%;
  }

  /* Modifications Section - Like Oil Coolers */
  .modifications-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: var(--space-4);
  }

  .modification-card {
    background: var(--color-white);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-5);
    transition: all 0.3s ease;
  }

  .modification-card:hover {
    transform: translateY(-4px);
    box-shadow: var(--shadow-lg);
    border-color: var(--color-accent);
  }

  .modification-header h3 {
    font-size: var(--text-lg);
    color: var(--color-primary);
    margin-bottom: var(--space-3);
    font-weight: 600;
  }

  .modification-description {
    color: var(--color-text-muted);
    font-size: var(--text-sm);
    line-height: 1.6;
  }

  /* Additional Services Style - For Technical Advantages */
  .additional-services-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: var(--space-4);
  }

  .additional-service-card {
    background: var(--color-bg-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-5);
    transition: all var(--transition-base);
  }

  .additional-service-card:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
    background: var(--color-white);
  }

  .additional-service-header {
    display: flex;
    align-items: center;
    gap: var(--space-3);
    margin-bottom: var(--space-3);
  }

  .additional-service-icon {
    width: 40px;
    height: 40px;
    flex-shrink: 0;
  }

  .additional-service-icon img {
    width: 100%;
    height: 100%;
    object-fit: contain;
  }

  .additional-service-card h3 {
    font-size: var(--text-lg);
    font-weight: 600;
    line-height: 1.3;
  }

  .additional-service-card p {
    color: var(--color-text-muted);
    font-size: var(--text-sm);
    line-height: 1.5;
  }

  /* Technical Features Section with 3D Turbine */
  .tech-features-infographic {
    position: relative;
    min-height: 600px;
    overflow: hidden;
    border-radius: var(--radius-xl);
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
  }

  .turbine-3d-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
  }

  .tech-features-content {
    position: relative;
    z-index: 2;
    padding: var(--space-8);
  }

  .tech-features-cards {
    display: flex;
    flex-direction: column;
    gap: var(--space-4);
    max-width: 420px;
  }

  @keyframes windSway {
    0%, 100% { transform: translateX(0) rotate(0deg); }
    25% { transform: translateX(-3px) rotate(-0.3deg); }
    50% { transform: translateX(-5px) rotate(-0.5deg); }
    75% { transform: translateX(-2px) rotate(-0.2deg); }
  }

  .infographic-card {
    background: rgba(255, 255, 255, 0.92);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(255, 255, 255, 0.5);
    border-radius: var(--radius-xl);
    padding: var(--space-5);
    position: relative;
    transition: box-shadow 0.4s ease, border-color 0.4s ease;
    overflow: hidden;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    animation: windSway 3s ease-in-out infinite;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    transition: all 0.3s ease;
  }

  .infographic-card:nth-child(1) { animation-delay: 0s; }
  .infographic-card:nth-child(2) { animation-delay: 0.4s; }
  .infographic-card:nth-child(3) { animation-delay: 0.8s; }
  .infographic-card:nth-child(4) { animation-delay: 1.2s; }

  .infographic-card:hover {
    animation-play-state: paused;
    transform: translateX(-5px) rotate(-0.3deg);
    box-shadow: 0 20px 40px rgba(163, 218, 243, 0.2), 0 10px 20px rgba(0, 0, 0, 0.1);
    border-color: var(--color-accent);
  }

  .card-icon {
    width: 44px;
    height: 44px;
    color: var(--color-primary);
    margin-bottom: var(--space-3);
    transition: all 0.3s ease;
  }

  .card-icon svg {
    width: 100%;
    height: 100%;
  }

  .infographic-card:hover .card-icon {
    color: var(--color-accent);
    transform: scale(1.1);
  }

  .infographic-card h3 {
    font-size: var(--text-md);
    font-weight: 600;
    color: var(--color-primary);
    margin-bottom: var(--space-2);
  }

  .infographic-card p {
    font-size: var(--text-sm);
    color: var(--color-text-muted);
    line-height: 1.5;
    margin: 0;
  }

  /* Calculator Section */
  .calculator-section {
    position: relative;
    border-radius: var(--radius-xl);
    padding: var(--space-10);
    overflow: hidden;
    background: linear-gradient(145deg, 
      rgba(255,255,255,0.9) 0%, 
      rgba(250,250,250,0.85) 50%, 
      rgba(245,245,245,0.8) 100%
    );
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    box-shadow: 
      0 8px 32px rgba(0,0,0,0.08),
      0 0 0 1px rgba(255,255,255,0.5),
      inset 0 1px 0 rgba(255,255,255,0.6);
    border: 1px solid rgba(255,255,255,0.3);
  }

  .calculator-wrapper {
    position: relative;
    z-index: 2;
  }

  .calculator-header {
    margin-bottom: var(--space-8);
  }

  .calculator-title h2 {
    font-size: var(--text-3xl);
    color: var(--color-primary);
    margin-bottom: var(--space-1);
    font-weight: 700;
  }

  .calculator-title p {
    color: var(--color-text-muted);
    font-size: var(--text-base);
  }

  .description-content {
    margin-bottom: var(--space-6);
  }

  .description-content h4 {
    font-size: var(--text-xl);
    color: var(--color-primary);
    margin-bottom: var(--space-4);
    font-weight: 600;
  }

  .calc-features {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    flex-direction: column;
    gap: var(--space-3);
  }

  .calc-features li {
    position: relative;
    padding-left: var(--space-5);
    font-size: var(--text-base);
    color: var(--color-text);
    line-height: 1.6;
  }

  .calc-features li::before {
    content: '';
    position: absolute;
    left: 0;
    top: 10px;
    width: 6px;
    height: 6px;
    background: var(--color-primary);
    border-radius: 50%;
  }

  .calc-features li strong {
    color: var(--color-primary);
  }

  .description-note {
    padding: var(--space-4);
  }

  .description-note h4 {
    font-size: var(--text-lg);
    color: var(--color-primary);
    margin-bottom: var(--space-3);
    font-weight: 600;
  }

  .description-note p {
    font-size: var(--text-base);
    color: var(--color-text-muted);
    line-height: 1.7;
  }

  .calculator-body {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-8);
    align-items: start;
  }

  .calculator-left {
    display: flex;
    flex-direction: column;
    gap: var(--space-4);
  }

  .calc-section-title {
    font-size: var(--text-lg);
    color: var(--color-primary);
    font-weight: 600;
    margin-bottom: var(--space-2);
  }

  .calculator-right {
    display: flex;
    flex-direction: column;
  }

  .form-icon-row {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: var(--space-3);
    width: 100%;
  }

  .form-group-modern {
    background: var(--color-white);
    border: 1px solid var(--color-border);
    border-radius: 50px;
    padding: var(--space-3) var(--space-5);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: var(--space-3);
  }

  .form-group-modern:hover,
  .form-group-modern:focus-within {
    border-color: var(--color-accent);
  }

  .input-wrapper {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    gap: var(--space-3);
  }

  .input-wrapper label {
    font-size: var(--text-base);
    color: var(--color-text-muted);
    white-space: nowrap;
  }

  .input-with-unit {
    display: flex;
    align-items: center;
    gap: var(--space-2);
  }

  .input-with-unit input {
    background: transparent;
    border: none;
    color: var(--color-primary);
    font-size: var(--text-lg);
    font-weight: 600;
    padding: 0;
    width: 60px;
    text-align: right;
    -moz-appearance: textfield;
  }

  .input-with-unit input::-webkit-outer-spin-button,
  .input-with-unit input::-webkit-inner-spin-button {
    -webkit-appearance: inner-spin-button;
    opacity: 1;
    margin-left: var(--space-2);
  }

  .input-with-unit input::placeholder {
    color: var(--color-text-muted);
  }

  .input-with-unit input:focus {
    outline: none;
  }

  .input-with-unit .unit {
    color: var(--color-text-muted);
    font-size: var(--text-base);
  }

  .input-wrapper select {
    background: transparent;
    border: none;
    color: var(--color-primary);
    font-size: var(--text-lg);
    font-weight: 600;
    padding: 0;
    cursor: pointer;
    text-align: right;
    direction: rtl;
  }

  .input-wrapper select:focus {
    outline: none;
  }

  .input-wrapper select option {
    background: var(--color-white);
    color: var(--color-primary);
    direction: ltr;
  }

  .calculator-form-card {
    display: flex;
    flex-direction: column;
    gap: var(--space-4);
    align-items: center;
  }

  .calculate-btn-modern {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    background: var(--color-accent);
    color: var(--color-primary);
    border: none;
    border-radius: 50px;
    padding: var(--space-3) var(--space-8);
    font-size: var(--text-base);
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    margin-top: var(--space-2);
    width: auto;
  }

  .calculate-btn-modern:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
    background: linear-gradient(134deg, var(--color-accent) 0%, var(--color-white) 100%);
  }

  .calculator-results-card {
    display: flex;
    flex-direction: column;
    transition: all 0.4s ease;
  }

  .calculator-results-card.active .result-card-value {
    color: var(--color-primary);
  }

  .results-header {
    margin-bottom: var(--space-3);
  }

  .results-header h4 {
    color: var(--color-primary);
    font-size: var(--text-lg);
    font-weight: 600;
  }

  .results-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: var(--space-3);
  }

  .result-card {
    background: var(--color-white);
    border: 1px solid var(--color-border);
    border-radius: 50px;
    padding: var(--space-3) var(--space-5);
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: var(--space-3);
    transition: all 0.3s ease;
  }

  .result-card:hover {
    border-color: var(--color-accent);
  }

  .result-card-label {
    font-size: var(--text-base);
    color: var(--color-text-muted);
    white-space: nowrap;
  }

  .result-card-value {
    font-size: var(--text-lg);
    font-weight: 600;
    color: var(--color-primary);
  }

  .calculator-note {
    font-size: var(--text-sm);
    color: var(--color-text-muted);
    text-align: left;
    margin-top: var(--space-4);
    font-style: italic;
  }

  /* Delivery Section */
  .delivery-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--space-6);
  }

  .delivery-card {
    position: relative;
    border-radius: var(--radius-xl);
    overflow: hidden;
    min-height: 350px;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    transition: all 0.3s ease;
  }

  .delivery-card:hover {
    transform: translateY(-4px);
    box-shadow: var(--shadow-xl);
  }

  .delivery-card:hover .delivery-bg-image {
    transform: scale(1.05);
  }

  .delivery-card:hover .delivery-description {
    opacity: 1;
    transform: translateY(0);
  }

  .delivery-card:hover .delivery-title-wrapper {
    transform: translateY(0);
  }

  .delivery-card:hover .delivery-tags {
    opacity: 1;
    transform: translateY(0);
  }

  .delivery-bg-image {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    z-index: 1;
    transition: transform 0.4s ease;
  }

  .delivery-content {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 2;
    padding: var(--space-6);
    display: flex;
    flex-direction: column;
    gap: var(--space-3);
    background: linear-gradient(to top, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0.3) 50%, transparent 100%);
  }

  .delivery-title-wrapper {
    display: inline-flex;
    align-self: flex-start;
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(255, 255, 255, 0.12);
    border-radius: 50px;
    padding: var(--space-3) var(--space-5);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
    transition: transform 0.4s ease;
    transform: translateY(80px);
  }

  .delivery-card h3 {
    font-size: var(--text-xl);
    color: var(--color-white);
    margin: 0;
    font-weight: 600;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  }

  .delivery-description {
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(255, 255, 255, 0.12);
    border-radius: 24px;
    padding: var(--space-4) var(--space-5);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.4s ease, transform 0.4s ease;
  }

  .delivery-card p {
    font-size: var(--text-base);
    color: var(--color-white);
    line-height: 1.6;
    margin: 0;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
  }

  .delivery-tags {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-2);
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.4s ease, transform 0.4s ease;
  }

  .tag {
    background: rgba(255, 255, 255, 0.15);
    color: var(--color-white);
    padding: var(--space-2) var(--space-3);
    border-radius: var(--radius-full);
    font-size: var(--text-sm);
    font-weight: 500;
    backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    white-space: nowrap;
  }

  /* Stats Section */
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: var(--space-4);
    background: var(--color-white);
    border-radius: var(--radius-xl);
    padding: var(--space-8);
    border: 1px solid var(--color-border);
  }

  .stat-card {
    text-align: center;
    padding: var(--space-4);
    border-right: 1px solid var(--color-border);
  }

  .stat-card:last-child {
    border-right: none;
  }

  .stat-value {
    font-size: var(--text-4xl);
    font-weight: 700;
    margin-bottom: var(--space-2);
    color: var(--color-primary);
  }

  .stat-label {
    font-size: var(--text-base);
    color: var(--color-text-muted);
  }

  /* Work Advantages Section */
  .work-advantages-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: var(--space-6);
  }

  .work-advantage-card {
    background: var(--color-bg-card);
    border-radius: var(--radius-xl);
    padding: var(--space-6);
    text-align: center;
    transition: all 0.3s ease;
  }

  .work-advantage-card:hover {
    transform: translateY(-4px);
    box-shadow: var(--shadow-lg);
  }

  .work-advantage-icon {
    width: 56px;
    height: 56px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto var(--space-4);
  }

  .work-advantage-icon img {
    width: 100%;
    height: 100%;
    object-fit: contain;
  }

  .work-advantage-card h3 {
    font-size: var(--text-lg);
    color: var(--color-primary);
    margin-bottom: var(--space-2);
  }

  .work-advantage-card p {
    color: var(--color-text-muted);
    line-height: 1.5;
    font-size: var(--text-sm);
  }

  /* CTA Section */
  .cta-section {
    background: var(--color-bg-card);
    border-radius: var(--radius-xl);
    padding: var(--space-12);
    text-align: center;
  }

  .cta-content {
    max-width: 600px;
    margin: 0 auto;
  }

  .cta-content h2 {
    font-size: var(--text-3xl);
    color: var(--color-primary);
    margin-bottom: var(--space-4);
  }

  .cta-content p {
    font-size: var(--text-lg);
    color: var(--color-text-muted);
    margin-bottom: var(--space-8);
    line-height: 1.6;
  }

  /* Responsive */
  @media (max-width: 1024px) {
    .about-turbines .about-content {
      grid-template-columns: 1fr;
    }

    .about-image {
      order: -1;
      min-height: 300px;
    }

    .modifications-grid {
      grid-template-columns: repeat(2, 1fr);
    }

    .calculator-body {
      grid-template-columns: 1fr;
    }

    .results-grid {
      grid-template-columns: repeat(2, 1fr);
    }

    .delivery-grid {
      grid-template-columns: 1fr;
    }

    .work-advantages-grid {
      grid-template-columns: repeat(2, 1fr);
    }

    .stats-grid {
      grid-template-columns: repeat(2, 1fr);
    }

    .stat-card {
      border-right: none;
      border-bottom: 1px solid var(--color-border);
    }
    
    .stat-card:nth-child(3),
    .stat-card:nth-child(4) {
      border-bottom: none;
    }

    .tech-features-infographic {
      min-height: 500px;
    }

    .tech-features-cards {
      max-width: 350px;
    }
  }

  @media (max-width: 768px) {
    .hero {
      padding: var(--space-10) var(--space-5);
      min-height: 350px;
    }

    .modifications-grid,
    .work-advantages-grid {
      grid-template-columns: 1fr;
    }

    .calculator-section {
      padding: var(--space-6);
    }

    .calculator-header {
      flex-direction: column;
      text-align: center;
    }

    .calculator-title h2 {
      font-size: var(--text-2xl);
    }

    .results-grid {
      grid-template-columns: 1fr;
    }

    .cta-section {
      padding: var(--space-8) var(--space-5);
    }

    .tech-features-infographic {
      min-height: 450px;
    }

    .tech-features-cards {
      max-width: 280px;
    }

    .infographic-card {
      padding: var(--space-4);
    }

    .infographic-card h3 {
      font-size: var(--text-sm);
    }

    .infographic-card p {
      font-size: 12px;
    }

    .delivery-grid {
      grid-template-columns: 1fr;
    }

    .delivery-card {
      min-height: 320px;
    }

    .delivery-title-wrapper {
      transform: translateY(0);
    }

    .delivery-description {
      opacity: 1;
      transform: translateY(0);
    }

    .delivery-tags {
      opacity: 1;
      transform: translateY(0);
    }
  }
</style>

